// Code generated by protoc-gen-gopb. DO NOT EDIT.
// Code generated by wpb. DO NOT EDIT.

package dbop

import (
	"errors"

	"github.com/walleframe/walle/util/protowire"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

type UserInfo struct {
	Uid   int64  `json:"uid,omitempty" db:"uid"`
	Name  string `json:"name,omitempty" db:"name"`
	Email string `json:"email,omitempty" db:"email"`
}

func (x *UserInfo) Reset() {
	*x = UserInfo{}
}

// MarshalObject marshal data to []byte
func (x *UserInfo) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *UserInfo) MarshalSize() (size int) {
	if x.Uid != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.Uid))
	}
	if len(x.Name) > 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeBytes(len(x.Name))
	}
	if len(x.Email) > 0 {
		// 1 = protowire.SizeTag(3)
		size += 1 + protowire.SizeBytes(len(x.Email))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *UserInfo) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Uid != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.Uid))
	}
	if len(x.Name) > 0 {
		// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
		data = append(data, 0x12)
		data = protowire.AppendString(data, x.Name)
	}
	if len(x.Email) > 0 {
		// data = protowire.AppendTag(data, 3, protowire.BytesType) => 00011010
		data = append(data, 0x1a)
		data = protowire.AppendString(data, x.Email)
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *UserInfo) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserInfo.Uid ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.Uid = int64(v)
		case 2:
			v, cnt := protowire.ConsumeString(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserInfo.Name ID:2 : invalid len value")
				return
			}
			index += cnt
			x.Name = v
		case 3:
			v, cnt := protowire.ConsumeString(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserInfo.Email ID:3 : invalid len value")
				return
			}
			index += cnt
			x.Email = v
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *UserInfo) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt64("uid", x.Uid)
	enc.AddString("name", x.Name)
	enc.AddString("email", x.Email)
	return nil
}

type ZapArrayUserInfo []*UserInfo

func (x ZapArrayUserInfo) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayUserInfo(name string, v []*UserInfo) zap.Field {
	return zap.Array(name, ZapArrayUserInfo(v))
}

// sql row extern data
type UserInfoEx struct {
	Uid         int64  `json:"uid,omitempty" db:"uid"`
	Name        string `json:"name,omitempty" db:"name"`
	Email       string `json:"email,omitempty" db:"email"`
	ModifyStamp int64  `json:"modify_stamp,omitempty" db:"modify_stamp"`
	CreateStamp int64  `json:"create_stamp,omitempty" db:"create_stamp"`
}

func (x *UserInfoEx) Reset() {
	*x = UserInfoEx{}
}

// MarshalObject marshal data to []byte
func (x *UserInfoEx) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *UserInfoEx) MarshalSize() (size int) {
	if x.Uid != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.Uid))
	}
	if len(x.Name) > 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeBytes(len(x.Name))
	}
	if len(x.Email) > 0 {
		// 1 = protowire.SizeTag(3)
		size += 1 + protowire.SizeBytes(len(x.Email))
	}
	if x.ModifyStamp != 0 {
		// 1 = protowire.SizeTag(4)
		size += 1 + protowire.SizeVarint(uint64(x.ModifyStamp))
	}
	if x.CreateStamp != 0 {
		// 1 = protowire.SizeTag(5)
		size += 1 + protowire.SizeVarint(uint64(x.CreateStamp))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *UserInfoEx) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Uid != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.Uid))
	}
	if len(x.Name) > 0 {
		// data = protowire.AppendTag(data, 2, protowire.BytesType) => 00010010
		data = append(data, 0x12)
		data = protowire.AppendString(data, x.Name)
	}
	if len(x.Email) > 0 {
		// data = protowire.AppendTag(data, 3, protowire.BytesType) => 00011010
		data = append(data, 0x1a)
		data = protowire.AppendString(data, x.Email)
	}
	if x.ModifyStamp != 0 {
		// data = protowire.AppendTag(data, 4, protowire.VarintType) => 00100000
		data = append(data, 0x20)
		data = protowire.AppendVarint(data, uint64(x.ModifyStamp))
	}
	if x.CreateStamp != 0 {
		// data = protowire.AppendTag(data, 5, protowire.VarintType) => 00101000
		data = append(data, 0x28)
		data = protowire.AppendVarint(data, uint64(x.CreateStamp))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *UserInfoEx) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserInfoEx.Uid ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.Uid = int64(v)
		case 2:
			v, cnt := protowire.ConsumeString(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserInfoEx.Name ID:2 : invalid len value")
				return
			}
			index += cnt
			x.Name = v
		case 3:
			v, cnt := protowire.ConsumeString(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserInfoEx.Email ID:3 : invalid len value")
				return
			}
			index += cnt
			x.Email = v
		case 4:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserInfoEx.ModifyStamp ID:4 : invalid varint value")
				return
			}
			index += cnt
			x.ModifyStamp = int64(v)
		case 5:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserInfoEx.CreateStamp ID:5 : invalid varint value")
				return
			}
			index += cnt
			x.CreateStamp = int64(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *UserInfoEx) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt64("uid", x.Uid)
	enc.AddString("name", x.Name)
	enc.AddString("email", x.Email)
	enc.AddInt64("modify_stamp", x.ModifyStamp)
	enc.AddInt64("create_stamp", x.CreateStamp)
	return nil
}

type ZapArrayUserInfoEx []*UserInfoEx

func (x ZapArrayUserInfoEx) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayUserInfoEx(name string, v []*UserInfoEx) zap.Field {
	return zap.Array(name, ZapArrayUserInfoEx(v))
}

type UserFriend struct {
	Uid   int64 `json:"uid,omitempty" db:"uid"`
	Fid   int64 `json:"fid,omitempty" db:"fid"`
	State int8  `json:"state,omitempty" db:"state"`
}

func (x *UserFriend) Reset() {
	*x = UserFriend{}
}

// MarshalObject marshal data to []byte
func (x *UserFriend) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *UserFriend) MarshalSize() (size int) {
	if x.Uid != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.Uid))
	}
	if x.Fid != 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeVarint(uint64(x.Fid))
	}
	if x.State != 0 {
		// 1 = protowire.SizeTag(3)
		size += 1 + protowire.SizeVarint(uint64(x.State))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *UserFriend) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Uid != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.Uid))
	}
	if x.Fid != 0 {
		// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
		data = append(data, 0x10)
		data = protowire.AppendVarint(data, uint64(x.Fid))
	}
	if x.State != 0 {
		// data = protowire.AppendTag(data, 3, protowire.VarintType) => 00011000
		data = append(data, 0x18)
		data = protowire.AppendVarint(data, uint64(x.State))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *UserFriend) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserFriend.Uid ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.Uid = int64(v)
		case 2:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserFriend.Fid ID:2 : invalid varint value")
				return
			}
			index += cnt
			x.Fid = int64(v)
		case 3:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserFriend.State ID:3 : invalid varint value")
				return
			}
			index += cnt
			x.State = int8(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *UserFriend) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt64("uid", x.Uid)
	enc.AddInt64("fid", x.Fid)
	enc.AddInt8("state", x.State)
	return nil
}

type ZapArrayUserFriend []*UserFriend

func (x ZapArrayUserFriend) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayUserFriend(name string, v []*UserFriend) zap.Field {
	return zap.Array(name, ZapArrayUserFriend(v))
}

// sql row extern data
type UserFriendEx struct {
	Uid         int64 `json:"uid,omitempty" db:"uid"`
	Fid         int64 `json:"fid,omitempty" db:"fid"`
	State       int8  `json:"state,omitempty" db:"state"`
	ModifyStamp int64 `json:"modify_stamp,omitempty" db:"modify_stamp"`
	CreateStamp int64 `json:"create_stamp,omitempty" db:"create_stamp"`
}

func (x *UserFriendEx) Reset() {
	*x = UserFriendEx{}
}

// MarshalObject marshal data to []byte
func (x *UserFriendEx) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *UserFriendEx) MarshalSize() (size int) {
	if x.Uid != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.Uid))
	}
	if x.Fid != 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeVarint(uint64(x.Fid))
	}
	if x.State != 0 {
		// 1 = protowire.SizeTag(3)
		size += 1 + protowire.SizeVarint(uint64(x.State))
	}
	if x.ModifyStamp != 0 {
		// 1 = protowire.SizeTag(4)
		size += 1 + protowire.SizeVarint(uint64(x.ModifyStamp))
	}
	if x.CreateStamp != 0 {
		// 1 = protowire.SizeTag(5)
		size += 1 + protowire.SizeVarint(uint64(x.CreateStamp))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *UserFriendEx) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Uid != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.Uid))
	}
	if x.Fid != 0 {
		// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
		data = append(data, 0x10)
		data = protowire.AppendVarint(data, uint64(x.Fid))
	}
	if x.State != 0 {
		// data = protowire.AppendTag(data, 3, protowire.VarintType) => 00011000
		data = append(data, 0x18)
		data = protowire.AppendVarint(data, uint64(x.State))
	}
	if x.ModifyStamp != 0 {
		// data = protowire.AppendTag(data, 4, protowire.VarintType) => 00100000
		data = append(data, 0x20)
		data = protowire.AppendVarint(data, uint64(x.ModifyStamp))
	}
	if x.CreateStamp != 0 {
		// data = protowire.AppendTag(data, 5, protowire.VarintType) => 00101000
		data = append(data, 0x28)
		data = protowire.AppendVarint(data, uint64(x.CreateStamp))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *UserFriendEx) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserFriendEx.Uid ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.Uid = int64(v)
		case 2:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserFriendEx.Fid ID:2 : invalid varint value")
				return
			}
			index += cnt
			x.Fid = int64(v)
		case 3:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserFriendEx.State ID:3 : invalid varint value")
				return
			}
			index += cnt
			x.State = int8(v)
		case 4:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserFriendEx.ModifyStamp ID:4 : invalid varint value")
				return
			}
			index += cnt
			x.ModifyStamp = int64(v)
		case 5:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserFriendEx.CreateStamp ID:5 : invalid varint value")
				return
			}
			index += cnt
			x.CreateStamp = int64(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *UserFriendEx) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt64("uid", x.Uid)
	enc.AddInt64("fid", x.Fid)
	enc.AddInt8("state", x.State)
	enc.AddInt64("modify_stamp", x.ModifyStamp)
	enc.AddInt64("create_stamp", x.CreateStamp)
	return nil
}

type ZapArrayUserFriendEx []*UserFriendEx

func (x ZapArrayUserFriendEx) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayUserFriendEx(name string, v []*UserFriendEx) zap.Field {
	return zap.Array(name, ZapArrayUserFriendEx(v))
}

type UserTest struct {
	Uid   int64 `json:"uid,omitempty" db:"uid"`
	Xxx   int64 `json:"xxx,omitempty" db:"xxx"`
	State int8  `json:"state,omitempty" db:"state"`
}

func (x *UserTest) Reset() {
	*x = UserTest{}
}

// MarshalObject marshal data to []byte
func (x *UserTest) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *UserTest) MarshalSize() (size int) {
	if x.Uid != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.Uid))
	}
	if x.Xxx != 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeVarint(uint64(x.Xxx))
	}
	if x.State != 0 {
		// 1 = protowire.SizeTag(3)
		size += 1 + protowire.SizeVarint(uint64(x.State))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *UserTest) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Uid != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.Uid))
	}
	if x.Xxx != 0 {
		// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
		data = append(data, 0x10)
		data = protowire.AppendVarint(data, uint64(x.Xxx))
	}
	if x.State != 0 {
		// data = protowire.AppendTag(data, 3, protowire.VarintType) => 00011000
		data = append(data, 0x18)
		data = protowire.AppendVarint(data, uint64(x.State))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *UserTest) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserTest.Uid ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.Uid = int64(v)
		case 2:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserTest.Xxx ID:2 : invalid varint value")
				return
			}
			index += cnt
			x.Xxx = int64(v)
		case 3:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserTest.State ID:3 : invalid varint value")
				return
			}
			index += cnt
			x.State = int8(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *UserTest) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt64("uid", x.Uid)
	enc.AddInt64("xxx", x.Xxx)
	enc.AddInt8("state", x.State)
	return nil
}

type ZapArrayUserTest []*UserTest

func (x ZapArrayUserTest) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayUserTest(name string, v []*UserTest) zap.Field {
	return zap.Array(name, ZapArrayUserTest(v))
}

// sql row extern data
type UserTestEx struct {
	Uid         int64 `json:"uid,omitempty" db:"uid"`
	Xxx         int64 `json:"xxx,omitempty" db:"xxx"`
	State       int8  `json:"state,omitempty" db:"state"`
	ModifyStamp int64 `json:"modify_stamp,omitempty" db:"modify_stamp"`
	CreateStamp int64 `json:"create_stamp,omitempty" db:"create_stamp"`
}

func (x *UserTestEx) Reset() {
	*x = UserTestEx{}
}

// MarshalObject marshal data to []byte
func (x *UserTestEx) MarshalObject() (data []byte, err error) {
	data = make([]byte, 0, x.MarshalSize())
	return x.MarshalObjectTo(data)
}

// MarshalSize calc marshal data need space
func (x *UserTestEx) MarshalSize() (size int) {
	if x.Uid != 0 {
		// 1 = protowire.SizeTag(1)
		size += 1 + protowire.SizeVarint(uint64(x.Uid))
	}
	if x.Xxx != 0 {
		// 1 = protowire.SizeTag(2)
		size += 1 + protowire.SizeVarint(uint64(x.Xxx))
	}
	if x.State != 0 {
		// 1 = protowire.SizeTag(3)
		size += 1 + protowire.SizeVarint(uint64(x.State))
	}
	if x.ModifyStamp != 0 {
		// 1 = protowire.SizeTag(4)
		size += 1 + protowire.SizeVarint(uint64(x.ModifyStamp))
	}
	if x.CreateStamp != 0 {
		// 1 = protowire.SizeTag(5)
		size += 1 + protowire.SizeVarint(uint64(x.CreateStamp))
	}
	return
}

// MarshalObjectTo marshal data to []byte
func (x *UserTestEx) MarshalObjectTo(buf []byte) (data []byte, err error) {
	data = buf
	if x.Uid != 0 {
		// data = protowire.AppendTag(data, 1, protowire.VarintType) => 00001000
		data = append(data, 0x8)
		data = protowire.AppendVarint(data, uint64(x.Uid))
	}
	if x.Xxx != 0 {
		// data = protowire.AppendTag(data, 2, protowire.VarintType) => 00010000
		data = append(data, 0x10)
		data = protowire.AppendVarint(data, uint64(x.Xxx))
	}
	if x.State != 0 {
		// data = protowire.AppendTag(data, 3, protowire.VarintType) => 00011000
		data = append(data, 0x18)
		data = protowire.AppendVarint(data, uint64(x.State))
	}
	if x.ModifyStamp != 0 {
		// data = protowire.AppendTag(data, 4, protowire.VarintType) => 00100000
		data = append(data, 0x20)
		data = protowire.AppendVarint(data, uint64(x.ModifyStamp))
	}
	if x.CreateStamp != 0 {
		// data = protowire.AppendTag(data, 5, protowire.VarintType) => 00101000
		data = append(data, 0x28)
		data = protowire.AppendVarint(data, uint64(x.CreateStamp))
	}
	return
}

// UnmarshalObject unmarshal data from []byte
func (x *UserTestEx) UnmarshalObject(data []byte) (err error) {
	index := 0
	for index < len(data) {
		num, typ, cnt := protowire.ConsumeTag(data[index:])
		if num == 0 {
			err = errors.New("invalid tag")
			return
		}

		index += cnt
		switch num {
		case 1:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserTestEx.Uid ID:1 : invalid varint value")
				return
			}
			index += cnt
			x.Uid = int64(v)
		case 2:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserTestEx.Xxx ID:2 : invalid varint value")
				return
			}
			index += cnt
			x.Xxx = int64(v)
		case 3:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserTestEx.State ID:3 : invalid varint value")
				return
			}
			index += cnt
			x.State = int8(v)
		case 4:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserTestEx.ModifyStamp ID:4 : invalid varint value")
				return
			}
			index += cnt
			x.ModifyStamp = int64(v)
		case 5:
			v, cnt := protowire.ConsumeVarint(data[index:])
			if cnt < 1 {
				err = errors.New("parse UserTestEx.CreateStamp ID:5 : invalid varint value")
				return
			}
			index += cnt
			x.CreateStamp = int64(v)
		default: // skip fields
			cnt = protowire.ConsumeFieldValue(num, typ, data[index:])
			if cnt < 0 {
				return protowire.ParseError(cnt)
			}
			index += cnt
		}
	}

	return
}

func (x *UserTestEx) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt64("uid", x.Uid)
	enc.AddInt64("xxx", x.Xxx)
	enc.AddInt8("state", x.State)
	enc.AddInt64("modify_stamp", x.ModifyStamp)
	enc.AddInt64("create_stamp", x.CreateStamp)
	return nil
}

type ZapArrayUserTestEx []*UserTestEx

func (x ZapArrayUserTestEx) MarshalLogArray(ae zapcore.ArrayEncoder) error {
	for _, v := range x {
		ae.AppendObject(v)
	}
	return nil
}

func LogArrayUserTestEx(name string, v []*UserTestEx) zap.Field {
	return zap.Array(name, ZapArrayUserTestEx(v))
}
