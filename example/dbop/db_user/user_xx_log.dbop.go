// Code generated by wpb. DO NOT EDIT.
package db_user

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"sync/atomic"

	"github.com/jmoiron/sqlx"
	"github.com/walleframe/svc_db"
	"github.com/walleframe/svc_db/example/dbop"
	"github.com/walleframe/walle/util"
)

////////////////////////////////////////////////////////////////////////////////
// public interface

type UserXxLogKey = int64

type UserXxLogOperation interface {
	Insert(ctx context.Context, data *dbop.UserXxLog) (res sql.Result, err error)
	InsertMany(ctx context.Context, datas []*dbop.UserXxLog) (res sql.Result, err error)

	Find(ctx context.Context, id int64) (data *dbop.UserXxLog, err error)
	Delete(ctx context.Context, id int64) (res sql.Result, err error)

	FindByKey(ctx context.Context, id UserXxLogKey) (data *dbop.UserXxLog, err error)
	DeleteByKey(ctx context.Context, id UserXxLogKey) (res sql.Result, err error)

	FindByKeyArray(ctx context.Context, ids []UserXxLogKey) (datas []*dbop.UserXxLog, err error)
	DeleteByKeyArray(ctx context.Context, ids []UserXxLogKey) (res sql.Result, err error)

	Where(bufSize int) *UserXxLogWhereStmt
	Select(ctx context.Context, where *UserXxLogWhereStmt) (datas []*dbop.UserXxLog, err error)
	Count(ctx context.Context, where *UserXxLogWhereStmt) (count int, err error)

	DeleteMany(ctx context.Context, where *UserXxLogWhereStmt) (res sql.Result, err error)

	RangeAll(ctx context.Context, where *UserXxLogWhereStmt, f func(ctx context.Context, row *dbop.UserXxLog) bool) error
	AllData(ctx context.Context, where *UserXxLogWhereStmt) (datas []*dbop.UserXxLog, err error)

	// use for custom named sql
	DB() *sqlx.DB
}

var (
	UserXxLogIdUnamrshal          = svc_db.RawToInt64
	UserXxLogUidUnamrshal         = svc_db.RawToInt64
	UserXxLogXxUnamrshal          = svc_db.RawToInt64
	UserXxLogX2Unamrshal          = svc_db.RawToString
	UserXxLogCreateStampUnamrshal = svc_db.RawToStampInt64

	UserXxLogCreateStampMarshal = svc_db.AnyFromStampInt64
)

var (
	globalUserXxLogOP atomic.Pointer[xUserXxLogOperation]
)

func init() {
	svc_db.RegisterSyncDBTable("mysql", "db_user", "user_xx_log", SyncUserXxLogDBTable)
	svc_db.RegisterDB("mysql", "db_user", "user_xx_log", func(db *sqlx.DB) error {
		//
		err := SyncUserXxLogDBTable(context.Background(), db)
		if err != nil {
			return fmt.Errorf("swap db_user.user_xx_log pointer, %w", err)
		}
		//
		tableOP, err := NewUserXxLogOperation(db)
		if err != nil {
			return fmt.Errorf("swap db_user.user_xx_log pointer, new table operation failed, %w", err)
		}

		globalUserXxLogOP.Store(tableOP)
		return nil
	})
}

var UserXxLogOP = func() UserXxLogOperation {
	return globalUserXxLogOP.Load()
}

func UserXxLogNamedSQL(bufSize int) *UserXxLogSQLWriter {
	sql := &UserXxLogSQLWriter{}
	sql.buf.Grow(bufSize)
	return sql
}

func SyncUserXxLogDBTable(ctx context.Context, db *sqlx.DB) (err error) {
	// sync table columns
	err = svc_db.SyncTableColumns(context.Background(), db, "user_xx_log", UserXxLogSQL_Create, UserXxLogSQL_TableColumns)
	if err != nil {
		return fmt.Errorf("sync db_user.user_xx_log table, sync columns failed, %w", err)
	}
	return
}

func UserXxLogToPrimaryKeys(rows []*dbop.UserXxLog) (ids []UserXxLogKey) {
	ids = make([]UserXxLogKey, 0, len(rows))
	for _, v := range rows {
		ids = append(ids, v.Id)
	}
	return
}

////////////////////////////////////////////////////////////////////////////////
// sql statement

const (
	UserXxLogSQL_Insert        = "insert user_xx_log(`uid`,`xx`,`x2`,`create_stamp`) values(?,?,?,?)"
	UserXxLogSQL_Insert2       = "insert user_xx_log(`id`,`uid`,`xx`,`x2`,`create_stamp`) values(?,?,?,?,?)"
	UserXxLogSQL_InsertValues  = ",(?,?,?,?)"
	UserXxLogSQL_InsertValues2 = ",(?,?,?,?,?)"
	UserXxLogSQL_Where1        = " where (`id`=?)"
	UserXxLogSQL_Where2        = " or (`id`=?)"
	UserXxLogSQL_Upsert        = "insert user_xx_log(`id`,`uid`,`xx`,`x2`,`create_stamp`) values(?,?,?,?,?)"
	UserXxLogSQL_UpsertUpdate  = " on duplicate key update `uid`=values(`uid`),`xx`=values(`xx`),`x2`=values(`x2`),`create_stamp`=values(`create_stamp`)"
	UserXxLogSQL_Update        = "update user_xx_log set `uid`=?,`xx`=?,`x2`=?,`create_stamp`=? where `id`=?"
	UserXxLogSQL_Delete        = "delete from user_xx_log"
	UserXxLogSQL_Find          = "select `id`,`uid`,`xx`,`x2`,`create_stamp` from user_xx_log"
	UserXxLogSQL_Count         = "select count(*) from user_xx_log"
	UserXxLogSQL_Create        = "create table user_xx_log (" +
		"`id` bigint not null auto_increment" +
		",`uid` bigint not null default 0" +
		",`xx` bigint not null default 0" +
		",`x2` varchar(64) not null default ''" +
		",`create_stamp` timestamp default current_timestamp" +
		",PRIMARY KEY ( `id`)" +
		") ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;"
)

var (
	UserXxLogSQL_TableColumns = map[string]string{
		"id":           "alter table user_xx_log add `id` bigint not null auto_increment;",
		"uid":          "alter table user_xx_log add `uid` bigint not null default 0;",
		"xx":           "alter table user_xx_log add `xx` bigint not null default 0;",
		"x2":           "alter table user_xx_log add `x2` varchar(64) not null default '';",
		"create_stamp": "alter table user_xx_log add `create_stamp` timestamp default current_timestamp;",
	}
)

////////////////////////////////////////////////////////////////////////////////
// TblTestOperation impl

type xUserXxLogOperation struct {
	db      *sqlx.DB
	insert  *sql.Stmt
	insert2 *sql.Stmt // increment id
	delete  *sql.Stmt
	find    *sql.Stmt
}

func NewUserXxLogOperation(db *sqlx.DB) (_ *xUserXxLogOperation, err error) {
	t := &xUserXxLogOperation{
		db: db,
	}

	t.insert, err = db.Prepare(UserXxLogSQL_Insert)
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_xx_log insert failed,%w", err)
	}
	t.insert2, err = db.Prepare(UserXxLogSQL_Insert2)
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_xx_log insert2 failed,%w", err)
	}
	t.delete, err = db.Prepare(UserXxLogSQL_Delete + " where `id`=?")
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_xx_log delete failed,%w", err)
	}
	t.find, err = db.Prepare(UserXxLogSQL_Find + " where `id`=?")
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_xx_log find failed,%w", err)
	}

	return t, nil
}

func (t *xUserXxLogOperation) Insert(ctx context.Context, data *dbop.UserXxLog) (res sql.Result, err error) {
	// auto increment field
	if data.Id != 0 {
		res, err = t.insert2.ExecContext(ctx, data.Id, data.Uid, data.Xx, data.X2, UserXxLogCreateStampMarshal(data.CreateStamp))
	} else {
		res, err = t.insert.ExecContext(ctx, data.Uid, data.Xx, data.X2, UserXxLogCreateStampMarshal(data.CreateStamp))
	}
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log insert failed,%w", err)
	}

	return
}

func (t *xUserXxLogOperation) InsertMany(ctx context.Context, datas []*dbop.UserXxLog) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return svc_db.EmptyResult{}, nil
	case 1:
		return t.Insert(ctx, datas[0])
	}

	// auto increment field
	withID := datas[0].Id != 0
	// 必须都设置了 incr id 或者都没有设置 incr.
	for i := 1; i < len(datas); i++ {
		if withID != (datas[i].Id != 0) {
			return nil, fmt.Errorf("exec db_user.user_xx_log check failed, auto increment field not match. frist:%t %d:%t", withID, i, !withID)
		}
	}
	if withID {
		buf := util.Builder{}
		buf.Grow(len(UserXxLogSQL_Insert2) + (len(datas)-1)*len(UserXxLogSQL_InsertValues2))
		buf.Write([]byte(UserXxLogSQL_Insert2))
		for i := 0; i < len(datas)-1; i++ {
			buf.Write([]byte(UserXxLogSQL_InsertValues2))
		}
		args := make([]any, 0, len(datas)*5)
		for i := 0; i < len(datas); i++ {
			data := datas[i]
			args = append(args, data.Id, data.Uid, data.Xx, data.X2, UserXxLogCreateStampMarshal(data.CreateStamp))
		}
		res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
		if err != nil {
			return nil, fmt.Errorf("exec db_user.user_xx_log insert_many withid failed,%w", err)
		}
		return
	}

	buf := util.Builder{}
	buf.Grow(len(UserXxLogSQL_Insert) + (len(datas)-1)*len(UserXxLogSQL_InsertValues))
	buf.Write([]byte(UserXxLogSQL_Insert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte(UserXxLogSQL_InsertValues))
	}
	args := make([]any, 0, len(datas)*4)
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, data.Uid, data.Xx, data.X2, UserXxLogCreateStampMarshal(data.CreateStamp))
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log insert_many failed,%w", err)
	}
	return
}

// find by primary key
func (t *xUserXxLogOperation) Find(ctx context.Context, id int64) (data *dbop.UserXxLog, err error) {
	rows, err := t.find.QueryContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log find failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return scanUserXxLog(rows)
	}
	return
}

func (t *xUserXxLogOperation) Delete(ctx context.Context, id int64) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log delete failed,%w", err)
	}

	return
}

// find by primary key
func (t *xUserXxLogOperation) FindByKey(ctx context.Context, id UserXxLogKey) (data *dbop.UserXxLog, err error) {
	rows, err := t.find.QueryContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log find_by_key failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		return scanUserXxLog(rows)
	}
	return
}

func (t *xUserXxLogOperation) DeleteByKey(ctx context.Context, id UserXxLogKey) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log del_by_key failed,%w", err)
	}

	return
}

// find by primary key
func (t *xUserXxLogOperation) FindByKeyArray(ctx context.Context, ids []UserXxLogKey) (datas []*dbop.UserXxLog, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := t.FindByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*dbop.UserXxLog{data}, nil
	}
	buf := util.Builder{}
	buf.Grow(len(UserXxLogSQL_Find) + len(UserXxLogSQL_Where1) + (len(ids)-1)*len(UserXxLogSQL_Where2))
	buf.Write([]byte(UserXxLogSQL_Find))
	buf.Write([]byte(UserXxLogSQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte(UserXxLogSQL_Where2))
	}

	args := make([]any, 0, len(ids)*1)
	for i := 0; i < len(ids); i++ {
		args = append(args, ids[i])
	}
	rows, err := t.db.DB.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log find_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserXxLog(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserXxLogOperation) DeleteByKeyArray(ctx context.Context, ids []UserXxLogKey) (res sql.Result, err error) {
	switch len(ids) {
	case 0:
		return svc_db.EmptyResult{}, nil
	case 1:
		return t.DeleteByKey(ctx, ids[0])
	}
	buf := util.Builder{}
	buf.Grow(len(UserXxLogSQL_Delete) + len(UserXxLogSQL_Where1) + (len(ids)-1)*len(UserXxLogSQL_Where2))
	buf.Write([]byte(UserXxLogSQL_Delete))
	buf.Write([]byte(UserXxLogSQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte(UserXxLogSQL_Where2))
	}

	args := make([]any, 0, len(ids)*1)
	for i := 0; i < len(ids); i++ {
		args = append(args, ids[i])
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log del_by_key_array failed,%w", err)
	}
	return
}

func (t *xUserXxLogOperation) Where(bufSize int) *UserXxLogWhereStmt {
	w := &UserXxLogWhereStmt{}
	w.buf.Grow(bufSize)
	w.buf.Write([]byte(" where "))
	return w
}

func (t *xUserXxLogOperation) Select(ctx context.Context, where *UserXxLogWhereStmt) (datas []*dbop.UserXxLog, err error) {
	var findSql = UserXxLogSQL_Find
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	rows, err := t.db.QueryContext(ctx, findSql)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log select failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {

		data, err := scanUserXxLog(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserXxLogOperation) Count(ctx context.Context, where *UserXxLogWhereStmt) (count int, err error) {
	var findSql = UserXxLogSQL_Count
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	err = t.db.QueryRowContext(ctx, findSql).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec db_user.user_xx_log count failed,%w", err)
	}
	return
}

func (t *xUserXxLogOperation) DeleteMany(ctx context.Context, where *UserXxLogWhereStmt) (res sql.Result, err error) {
	var w string
	if where != nil {
		w = where.String()
	}
	buf := util.Builder{}
	buf.Grow(len(UserXxLogSQL_Delete) + len(w))
	buf.Write([]byte(UserXxLogSQL_Delete))
	buf.WriteString(w)
	res, err = t.db.ExecContext(ctx, buf.String())
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_xx_log delete_many failed,%w", err)
	}

	return
}

func (t *xUserXxLogOperation) RangeAll(ctx context.Context, where *UserXxLogWhereStmt, f func(ctx context.Context, row *dbop.UserXxLog) bool) error {
	var findSql = UserXxLogSQL_Find
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	count := 0
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return fmt.Errorf("exec db_user.user_xx_log range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := scanUserXxLog(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}

func (t *xUserXxLogOperation) AllData(ctx context.Context, where *UserXxLogWhereStmt) (datas []*dbop.UserXxLog, err error) {
	var findSql = UserXxLogSQL_Find
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	datas = make([]*dbop.UserXxLog, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return nil, fmt.Errorf("exec db_user.user_xx_log all_data failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := scanUserXxLog(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}

func (t *xUserXxLogOperation) DB() *sqlx.DB {
	return t.db
}

////////////////////////////////////////////////////////////////////////////////
// where stmt

type UserXxLogWhereStmt struct {
	buf           util.Builder
	limit, offset int
}

func (w *UserXxLogWhereStmt) Id() *svc_db.IntSignedCondition[UserXxLogWhereStmt, int64] {
	return svc_db.NewIntSignedCondition[UserXxLogWhereStmt, int64](w, &w.buf, "id")
}

func (w *UserXxLogWhereStmt) Uid() *svc_db.IntSignedCondition[UserXxLogWhereStmt, int64] {
	return svc_db.NewIntSignedCondition[UserXxLogWhereStmt, int64](w, &w.buf, "uid")
}

func (w *UserXxLogWhereStmt) Xx() *svc_db.IntSignedCondition[UserXxLogWhereStmt, int64] {
	return svc_db.NewIntSignedCondition[UserXxLogWhereStmt, int64](w, &w.buf, "xx")
}

func (w *UserXxLogWhereStmt) X2() *svc_db.StringCondition[UserXxLogWhereStmt] {
	return svc_db.NewStringCondition[UserXxLogWhereStmt](w, &w.buf, "x2")
}

func (w *UserXxLogWhereStmt) CreateStamp() *svc_db.IntSignedCondition[UserXxLogWhereStmt, int64] {
	return svc_db.NewIntSignedCondition[UserXxLogWhereStmt, int64](w, &w.buf, "create_stamp")
}

func (w *UserXxLogWhereStmt) Limit(limit, offset int) *UserXxLogWhereStmt {
	w.limit = limit
	w.offset = offset
	return w
}

func (w *UserXxLogWhereStmt) And() *UserXxLogWhereStmt {
	w.buf.Write([]byte(" and "))
	return w
}

func (w *UserXxLogWhereStmt) Or() *UserXxLogWhereStmt {
	w.buf.Write([]byte(" or "))
	return w
}

func (w *UserXxLogWhereStmt) Group(gf func(w *UserXxLogWhereStmt)) *UserXxLogWhereStmt {
	w.buf.WriteByte('(')
	gf(w)
	w.buf.WriteByte(')')
	return w
}

func (w *UserXxLogWhereStmt) Custom(f func(buf *util.Builder)) *UserXxLogWhereStmt {
	f(&w.buf)
	return w
}

func (w *UserXxLogWhereStmt) applyLimitAndOffset() {
	if w.limit == 0 && w.offset == 0 {
		return
	}
	w.buf.Write([]byte(" limit "))
	w.buf.WriteInt(w.offset)
	w.buf.WriteByte(',')
	w.buf.WriteInt(w.limit)
}

func (w *UserXxLogWhereStmt) String() string {
	return w.buf.String()
}

////////////////////////////////////////////////////////////////////////////////
// scan interface

func scanUserXxLog(rows *sql.Rows) (data *dbop.UserXxLog, err error) {
	var values [5]sql.RawBytes
	err = rows.Scan(&values[0], &values[1], &values[2], &values[3], &values[4])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_xx_log scan failed, %w", err)
	}

	data = &dbop.UserXxLog{}
	data.Id, err = UserXxLogIdUnamrshal(values[0])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_xx_log scan id failed, %w", err)
	}
	data.Uid, err = UserXxLogUidUnamrshal(values[1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_xx_log scan uid failed, %w", err)
	}
	data.Xx, err = UserXxLogXxUnamrshal(values[2])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_xx_log scan xx failed, %w", err)
	}
	data.X2, err = UserXxLogX2Unamrshal(values[3])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_xx_log scan x2 failed, %w", err)
	}
	data.CreateStamp, err = UserXxLogCreateStampUnamrshal(values[4])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_xx_log scan create_stamp failed, %w", err)
	}
	return data, nil
}

////////////////////////////////////////////////////////////////////////////////
// named sql

type UserXxLogSQLWriter struct {
	buf util.Builder
}

func (x *UserXxLogSQLWriter) Select() *UserXxLogNamedSelect {
	x.buf.Write([]byte("select "))
	var v int
	return &UserXxLogNamedSelect{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *UserXxLogSQLWriter) Update() *UserXxLogNamedUpdate {
	x.buf.Write([]byte("update user_xx_log set "))
	var v int
	return &UserXxLogNamedUpdate{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *UserXxLogSQLWriter) Insert() *UserXxLogNamedInsert {
	return &UserXxLogNamedInsert{
		buf: &x.buf,
	}
}

func (x *UserXxLogSQLWriter) Delete() *UserXxLogNamedWhere {
	x.buf.Write([]byte("delete from user_xx_log where "))
	return &UserXxLogNamedWhere{
		buf: &x.buf,
	}
}

type UserXxLogNamedInsert struct {
	buf          *util.Builder
	list, values []string
}

func (x *UserXxLogNamedInsert) Id() *UserXxLogNamedInsert {
	x.list = append(x.list, "`id`")
	x.values = append(x.values, ":id")
	return x
}

func (x *UserXxLogNamedInsert) Uid() *UserXxLogNamedInsert {
	x.list = append(x.list, "`uid`")
	x.values = append(x.values, ":uid")
	return x
}

func (x *UserXxLogNamedInsert) Xx() *UserXxLogNamedInsert {
	x.list = append(x.list, "`xx`")
	x.values = append(x.values, ":xx")
	return x
}

func (x *UserXxLogNamedInsert) X2() *UserXxLogNamedInsert {
	x.list = append(x.list, "`x2`")
	x.values = append(x.values, ":x2")
	return x
}

func (x *UserXxLogNamedInsert) CreateStamp() *UserXxLogNamedInsert {
	x.list = append(x.list, "`create_stamp`")
	x.values = append(x.values, ":create_stamp")
	return x
}

func (x *UserXxLogNamedInsert) ToSQL() string {
	x.buf.Write([]byte("insert user_xx_log("))
	x.buf.WriteString(strings.Join(x.list, ","))
	x.buf.Write([]byte(") values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

func (x *UserXxLogNamedInsert) ValuesToSQL() string {
	x.buf.Write([]byte(",values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

type UserXxLogNamedUpdate struct {
	buf    *util.Builder
	n      *int
	values *bool
}

func (x *UserXxLogNamedUpdate) Id() *UserXxLogNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`id`=values(`id`)"))
	} else {
		x.buf.Write([]byte("`id`=:id"))
	}
	*x.n++
	return x
}

func (x *UserXxLogNamedUpdate) Uid() *UserXxLogNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`uid`=values(`uid`)"))
	} else {
		x.buf.Write([]byte("`uid`=:uid"))
	}
	*x.n++
	return x
}

func (x *UserXxLogNamedUpdate) Xx() *UserXxLogNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`xx`=values(`xx`)"))
	} else {
		x.buf.Write([]byte("`xx`=:xx"))
	}
	*x.n++
	return x
}

func (x *UserXxLogNamedUpdate) X2() *UserXxLogNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`x2`=values(`x2`)"))
	} else {
		x.buf.Write([]byte("`x2`=:x2"))
	}
	*x.n++
	return x
}

func (x *UserXxLogNamedUpdate) CreateStamp() *UserXxLogNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`create_stamp`=values(`create_stamp`)"))
	} else {
		x.buf.Write([]byte("`create_stamp`=:create_stamp"))
	}
	*x.n++
	return x
}

func (x *UserXxLogNamedUpdate) Where() *UserXxLogNamedWhere {
	if x.values != nil {
		panic("invalid where")
	}
	x.buf.Write([]byte(" where "))
	return &UserXxLogNamedWhere{
		buf: x.buf,
	}
}

func (x *UserXxLogNamedUpdate) ToSQL() string {
	return x.buf.String()
}

type UserXxLogNamedSelect struct {
	buf *util.Builder
	n   *int
}

func (x *UserXxLogNamedSelect) Id() *UserXxLogNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`id`"))
	*x.n++
	return x
}

func (x *UserXxLogNamedSelect) Uid() *UserXxLogNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`uid`"))
	*x.n++
	return x
}

func (x *UserXxLogNamedSelect) Xx() *UserXxLogNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`xx`"))
	*x.n++
	return x
}

func (x *UserXxLogNamedSelect) X2() *UserXxLogNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`x2`"))
	*x.n++
	return x
}

func (x *UserXxLogNamedSelect) CreateStamp() *UserXxLogNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`create_stamp`"))
	*x.n++
	return x
}

func (x *UserXxLogNamedSelect) Where() *UserXxLogNamedWhere {
	x.buf.Write([]byte(" from user_xx_log where "))
	return &UserXxLogNamedWhere{
		buf: x.buf,
	}
}

func (x *UserXxLogNamedSelect) ToSQL() string {
	x.buf.Write([]byte(" from user_xx_log"))
	return x.buf.String()
}

type UserXxLogNamedWhere struct {
	buf *util.Builder
}

func (x *UserXxLogNamedWhere) Id() *UserXxLogNamedWhere {
	x.buf.Write([]byte("`id` = :id"))
	return x
}

func (x *UserXxLogNamedWhere) Uid() *UserXxLogNamedWhere {
	x.buf.Write([]byte("`uid` = :uid"))
	return x
}

func (x *UserXxLogNamedWhere) Xx() *UserXxLogNamedWhere {
	x.buf.Write([]byte("`xx` = :xx"))
	return x
}

func (x *UserXxLogNamedWhere) X2() *UserXxLogNamedWhere {
	x.buf.Write([]byte("`x2` = :x2"))
	return x
}

func (x *UserXxLogNamedWhere) CreateStamp() *UserXxLogNamedWhere {
	x.buf.Write([]byte("`create_stamp` = :create_stamp"))
	return x
}

func (x *UserXxLogNamedWhere) Limit(limit, offset int) *UserXxLogNamedWhere {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *UserXxLogNamedWhere) And() *UserXxLogNamedWhere {
	x.buf.Write([]byte(" and "))
	return x
}

func (x *UserXxLogNamedWhere) Or() *UserXxLogNamedWhere {
	x.buf.Write([]byte(" or "))
	return x
}

func (x *UserXxLogNamedWhere) Group(gf func(w *UserXxLogNamedWhere)) *UserXxLogNamedWhere {
	x.buf.WriteByte('(')
	gf(x)
	x.buf.WriteByte(')')
	return x
}

func (x *UserXxLogNamedWhere) Custom(f func(buf *util.Builder)) *UserXxLogNamedWhere {
	f(x.buf)
	return x
}

func (x *UserXxLogNamedWhere) OnDuplicateKeyUpdate() *UserXxLogNamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := false
	return &UserXxLogNamedUpdate{
		buf:    x.buf,
		n:      &v,
		values: &values,
	}
}

func (x *UserXxLogNamedWhere) OnDuplicateKeyUpdateValues() *UserXxLogNamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := true
	return &UserXxLogNamedUpdate{
		buf:    x.buf,
		n:      &v,
		values: &values,
	}
}

func (x *UserXxLogNamedWhere) ToSQL() string {
	return x.buf.String()
}

func (x *UserXxLogNamedWhere) OrderBy() *UserXxLogNamedOrderBy {
	x.buf.Write([]byte(" order by "))
	var v int
	return &UserXxLogNamedOrderBy{
		buf: x.buf,
		n:   &v,
	}
}

type UserXxLogNamedOrderBy struct {
	buf *util.Builder
	n   *int
}

func (x *UserXxLogNamedOrderBy) Id() *UserXxLogNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`id`"))
	*x.n++
	return &UserXxLogNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserXxLogNamedOrderBy) Uid() *UserXxLogNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`uid`"))
	*x.n++
	return &UserXxLogNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserXxLogNamedOrderBy) Xx() *UserXxLogNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`xx`"))
	*x.n++
	return &UserXxLogNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserXxLogNamedOrderBy) X2() *UserXxLogNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`x2`"))
	*x.n++
	return &UserXxLogNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserXxLogNamedOrderBy) CreateStamp() *UserXxLogNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`create_stamp`"))
	*x.n++
	return &UserXxLogNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserXxLogNamedOrderBy) Limit(limit, offset int) *UserXxLogNamedOrderBy {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *UserXxLogNamedOrderBy) ToSQL() string {
	return x.buf.String()
}

type UserXxLogNamedOrderAsc struct {
	buf *util.Builder
	n   *int
}

func (x *UserXxLogNamedOrderAsc) Asc() *UserXxLogNamedOrderBy {
	x.buf.Write([]byte(" asc "))
	return &UserXxLogNamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserXxLogNamedOrderAsc) Desc() *UserXxLogNamedOrderBy {
	x.buf.Write([]byte(" desc "))
	return &UserXxLogNamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserXxLogNamedOrderAsc) ToSQL() string {
	return x.buf.String()
}
