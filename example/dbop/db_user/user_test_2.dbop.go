// Code generated by wpb. DO NOT EDIT.
package db_user

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"sync/atomic"

	"github.com/jmoiron/sqlx"
	"github.com/walleframe/svc_db"
	"github.com/walleframe/svc_db/example/dbop"
	"github.com/walleframe/walle/util"
)

////////////////////////////////////////////////////////////////////////////////
// public interface

type UserTest2Key = int64

type UserTest2Operation interface {
	Insert(ctx context.Context, data *dbop.UserTest2) (res sql.Result, err error)
	InsertMany(ctx context.Context, datas []*dbop.UserTest2) (res sql.Result, err error)

	Update(ctx context.Context, data *dbop.UserTest2) (res sql.Result, err error)
	Upsert(ctx context.Context, data *dbop.UserTest2) (res sql.Result, err error)
	UpsertMany(ctx context.Context, datas []*dbop.UserTest2) (res sql.Result, err error)

	Find(ctx context.Context, uid int64) (data *dbop.UserTest2, err error)
	FindEx(ctx context.Context, uid int64) (data *dbop.UserTest2Ex, err error)
	Delete(ctx context.Context, uid int64) (res sql.Result, err error)

	FindByKey(ctx context.Context, id UserTest2Key) (data *dbop.UserTest2, err error)
	FindExByKey(ctx context.Context, id UserTest2Key) (data *dbop.UserTest2Ex, err error)
	DeleteByKey(ctx context.Context, id UserTest2Key) (res sql.Result, err error)

	FindByKeyArray(ctx context.Context, ids []UserTest2Key) (datas []*dbop.UserTest2, err error)
	FindExByKeyArray(ctx context.Context, ids []UserTest2Key) (datas []*dbop.UserTest2Ex, err error)
	DeleteByKeyArray(ctx context.Context, ids []UserTest2Key) (res sql.Result, err error)

	FindByIndexUniqueTest(ctx context.Context, uid int64, xxx int64, limit, offset int) (datas []*dbop.UserTest2, err error)
	FindExByIndexUniqueTest(ctx context.Context, uid int64, xxx int64, limit, offset int) (datas []*dbop.UserTest2Ex, err error)
	CountByIndexUniqueTest(ctx context.Context, uid int64, xxx int64) (count int, err error)
	DeleteByIndexUniqueTest(ctx context.Context, uid int64, xxx int64) (res sql.Result, err error)

	FindByIndexXxx(ctx context.Context, uid int64, limit, offset int) (datas []*dbop.UserTest2, err error)
	FindExByIndexXxx(ctx context.Context, uid int64, limit, offset int) (datas []*dbop.UserTest2Ex, err error)
	CountByIndexXxx(ctx context.Context, uid int64) (count int, err error)
	DeleteByIndexXxx(ctx context.Context, uid int64) (res sql.Result, err error)

	Where(bufSize int) *UserTest2WhereStmt
	Select(ctx context.Context, where *UserTest2WhereStmt) (datas []*dbop.UserTest2, err error)
	SelectEx(ctx context.Context, where *UserTest2WhereStmt) (datas []*dbop.UserTest2Ex, err error)
	Count(ctx context.Context, where *UserTest2WhereStmt) (count int, err error)

	DeleteMany(ctx context.Context, where *UserTest2WhereStmt) (res sql.Result, err error)

	RangeAll(ctx context.Context, where *UserTest2WhereStmt, f func(ctx context.Context, row *dbop.UserTest2) bool) error
	RangeAllEx(ctx context.Context, where *UserTest2WhereStmt, f func(ctx context.Context, row *dbop.UserTest2Ex) bool) error
	AllData(ctx context.Context, where *UserTest2WhereStmt) (datas []*dbop.UserTest2, err error)
	AllDataEx(ctx context.Context, where *UserTest2WhereStmt) (datas []*dbop.UserTest2Ex, err error)

	// use for custom named sql
	DB() *sqlx.DB
}

var (
	UserTest2UidUnamrshal       = svc_db.RawToInt64
	UserTest2XxxUnamrshal       = svc_db.RawToInt64
	UserTest2StateUnamrshal     = svc_db.RawToInt8
	UserTest2CustomValUnamrshal = svc_db.RawToString

	UserTest2UidMarshal       = svc_db.AnyFromAny[int64]
	UserTest2CustomValMarshal = svc_db.AnyFromAny[string]
)

var (
	globalUserTest2OP atomic.Pointer[xUserTest2Operation]
)

func init() {
	svc_db.RegisterSyncDBTable("mysql", "db_user", "user_test_2", SyncUserTest2DBTable)
	svc_db.RegisterDB("mysql", "db_user", "user_test_2", func(db *sqlx.DB) error {
		//
		err := SyncUserTest2DBTable(context.Background(), db)
		if err != nil {
			return fmt.Errorf("swap db_user.user_test_2 pointer, %w", err)
		}
		//
		tableOP, err := NewUserTest2Operation(db)
		if err != nil {
			return fmt.Errorf("swap db_user.user_test_2 pointer, new table operation failed, %w", err)
		}

		globalUserTest2OP.Store(tableOP)
		return nil
	})
}

var UserTest2OP = func() UserTest2Operation {
	return globalUserTest2OP.Load()
}

func UserTest2NamedSQL(bufSize int) *UserTest2SQLWriter {
	sql := &UserTest2SQLWriter{}
	sql.buf.Grow(bufSize)
	return sql
}

func SyncUserTest2DBTable(ctx context.Context, db *sqlx.DB) (err error) {
	// sync table columns
	err = svc_db.SyncTableColumns(context.Background(), db, "user_test_2", UserTest2SQL_Create, UserTest2SQL_TableColumns)
	if err != nil {
		return fmt.Errorf("sync db_user.user_test_2 table, sync columns failed, %w", err)
	}
	// sync table index
	err = svc_db.SyncTableIndex(context.Background(), db, "user_test_2", UserTest2SQL_TableIndex)
	if err != nil {
		return fmt.Errorf("sync db_user.user_test_2 table, sync index failed, %w", err)
	}
	return
}

func UserTest2ToPrimaryKeys(rows []*dbop.UserTest2) (ids []UserTest2Key) {
	ids = make([]UserTest2Key, 0, len(rows))
	for _, v := range rows {
		ids = append(ids, v.Uid)
	}
	return
}

func UserTest2ExToPrimaryKeysEx(rows []*dbop.UserTest2Ex) (ids []UserTest2Key) {
	ids = make([]UserTest2Key, 0, len(rows))
	for _, v := range rows {
		ids = append(ids, v.Uid)
	}
	return
}

////////////////////////////////////////////////////////////////////////////////
// sql statement

const (
	UserTest2SQL_Insert        = "insert user_test_2(`uid`,`xxx`,`state`,`custom_val`) values(?,?,?,?)"
	UserTest2SQL_InsertValues  = ",(?,?,?,?)"
	UserTest2SQL_InsertValues2 = ",(?,?,?,?)"
	UserTest2SQL_Where1        = " where (`uid`=?)"
	UserTest2SQL_Where2        = " or (`uid`=?)"
	UserTest2SQL_Upsert        = "insert user_test_2(`uid`,`xxx`,`state`,`custom_val`) values(?,?,?,?)"
	UserTest2SQL_UpsertUpdate  = " on duplicate key update `uid`=values(`uid`),`xxx`=values(`xxx`),`state`=values(`state`),`custom_val`=values(`custom_val`)"
	UserTest2SQL_Update        = "update user_test_2 set `xxx`=?,`state`=?,`custom_val`=? where `uid`=?"
	UserTest2SQL_Delete        = "delete from user_test_2"
	UserTest2SQL_Find          = "select `uid`,`xxx`,`state`,`custom_val` from user_test_2"
	UserTest2SQL_FindRow       = "select `uid`,`xxx`,`state`,`custom_val`,`modify_stamp`,`create_stamp` from user_test_2"
	UserTest2SQL_Count         = "select count(*) from user_test_2"
	UserTest2SQL_Create        = "create table user_test_2 (" +
		"`uid` bigint not null default 0" +
		",`xxx` bigint not null default 0" +
		",`state` tinyint not null default 0" +
		",`custom_val` varchar(64) not null default ''" +
		",`modify_stamp` timestamp default current_timestamp on update current_timestamp" +
		",`create_stamp` timestamp default current_timestamp" +
		",PRIMARY KEY ( `uid`)" +
		") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;"
)

var (
	UserTest2SQL_TableColumns = map[string]string{
		"uid":        "alter table user_test_2 add `uid` bigint not null default 0;",
		"xxx":        "alter table user_test_2 add `xxx` bigint not null default 0;",
		"state":      "alter table user_test_2 add `state` tinyint not null default 0;",
		"custom_val": "alter table user_test_2 add `custom_val` varchar(64) not null default '';",
	}
	UserTest2SQL_TableIndex = map[string]string{
		"user_test_2_unique_test": "create unique index user_test_2_unique_test on user_test_2(`uid`,`xxx`)",
		"user_test_2_xxx":         "create index user_test_2_xxx on user_test_2(`uid`)",
	}
)

////////////////////////////////////////////////////////////////////////////////
// TblTestOperation impl

type xUserTest2Operation struct {
	db                  *sqlx.DB
	insert              *sql.Stmt
	update              *sql.Stmt
	upsert              *sql.Stmt
	delete              *sql.Stmt
	find                *sql.Stmt
	findRow             *sql.Stmt
	idxUniqueTestFind   *sql.Stmt
	idxUniqueTestFindEx *sql.Stmt
	idxUniqueTestCount  *sql.Stmt
	idxUniqueTestDelete *sql.Stmt
	idxXxxFind          *sql.Stmt
	idxXxxFindEx        *sql.Stmt
	idxXxxCount         *sql.Stmt
	idxXxxDelete        *sql.Stmt
}

func NewUserTest2Operation(db *sqlx.DB) (_ *xUserTest2Operation, err error) {
	t := &xUserTest2Operation{
		db: db,
	}

	t.insert, err = db.Prepare(UserTest2SQL_Insert)
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_test_2 insert failed,%w", err)
	}
	t.update, err = db.Prepare(UserTest2SQL_Update)
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_test_2 update failed,%w", err)
	}
	t.upsert, err = db.Prepare(UserTest2SQL_Upsert + UserTest2SQL_UpsertUpdate)
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_test_2 upsert failed,%w", err)
	}
	t.delete, err = db.Prepare(UserTest2SQL_Delete + " where `uid`=?")
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_test_2 delete failed,%w", err)
	}
	t.find, err = db.Prepare(UserTest2SQL_Find + " where `uid`=?")
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_test_2 find failed,%w", err)
	}
	t.findRow, err = db.Prepare(UserTest2SQL_FindRow + " where `uid`=?")
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_test_2 findex failed,%w", err)
	}

	return t, nil
}

func (t *xUserTest2Operation) Insert(ctx context.Context, data *dbop.UserTest2) (res sql.Result, err error) {
	res, err = t.insert.ExecContext(ctx, UserTest2UidMarshal(data.Uid), data.Xxx, data.State, UserTest2CustomValMarshal(data.CustomVal))
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 insert failed,%w", err)
	}

	return
}

func (t *xUserTest2Operation) InsertMany(ctx context.Context, datas []*dbop.UserTest2) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return svc_db.EmptyResult{}, nil
	case 1:
		return t.Insert(ctx, datas[0])
	}

	buf := util.Builder{}
	buf.Grow(len(UserTest2SQL_Insert) + (len(datas)-1)*len(UserTest2SQL_InsertValues))
	buf.Write([]byte(UserTest2SQL_Insert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte(UserTest2SQL_InsertValues))
	}
	args := make([]any, 0, len(datas)*4)
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, UserTest2UidMarshal(data.Uid), data.Xxx, data.State, UserTest2CustomValMarshal(data.CustomVal))
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 insert_many failed,%w", err)
	}
	return
}

func (t *xUserTest2Operation) Update(ctx context.Context, data *dbop.UserTest2) (res sql.Result, err error) {
	res, err = t.update.ExecContext(ctx, data.Xxx, data.State, UserTest2CustomValMarshal(data.CustomVal), data.Uid)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 update failed,%w", err)
	}

	return
}

func (t *xUserTest2Operation) Upsert(ctx context.Context, data *dbop.UserTest2) (res sql.Result, err error) {

	res, err = t.upsert.ExecContext(ctx, UserTest2UidMarshal(data.Uid), data.Xxx, data.State, UserTest2CustomValMarshal(data.CustomVal))
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 upsert failed,%w", err)
	}

	return
}

func (t *xUserTest2Operation) UpsertMany(ctx context.Context, datas []*dbop.UserTest2) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return svc_db.EmptyResult{}, nil
	case 1:
		return t.Upsert(ctx, datas[0])
	}

	buf := util.Builder{}
	buf.Grow(len(UserTest2SQL_Upsert) + (len(datas)-1)*len(UserTest2SQL_InsertValues2) + len(UserTest2SQL_UpsertUpdate))
	buf.Write([]byte(UserTest2SQL_Upsert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte(UserTest2SQL_InsertValues2))
	}
	buf.Write([]byte(UserTest2SQL_UpsertUpdate))
	args := make([]any, 0, len(datas)*4)
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, UserTest2UidMarshal(data.Uid), data.Xxx, data.State, UserTest2CustomValMarshal(data.CustomVal))
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 upsert_many failed,%w", err)
	}
	return
}

// find by primary key
func (t *xUserTest2Operation) Find(ctx context.Context, uid int64) (data *dbop.UserTest2, err error) {
	rows, err := t.find.QueryContext(ctx, UserTest2UidMarshal(uid))
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 find failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return scanUserTest2(rows)
	}
	return
}

func (t *xUserTest2Operation) FindEx(ctx context.Context, uid int64) (data *dbop.UserTest2Ex, err error) {
	rows, err := t.findRow.QueryContext(ctx, UserTest2UidMarshal(uid))
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 findex failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return scanUserTest2Ex(rows)
	}
	return
}

func (t *xUserTest2Operation) Delete(ctx context.Context, uid int64) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 delete failed,%w", err)
	}

	return
}

// find by primary key
func (t *xUserTest2Operation) FindByKey(ctx context.Context, id UserTest2Key) (data *dbop.UserTest2, err error) {
	rows, err := t.find.QueryContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 find_by_key failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		return scanUserTest2(rows)
	}
	return
}

func (t *xUserTest2Operation) FindExByKey(ctx context.Context, id UserTest2Key) (data *dbop.UserTest2Ex, err error) {
	rows, err := t.findRow.QueryContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 findex_by_key failed,%w", err)
	}
	defer rows.Close()
	data = &dbop.UserTest2Ex{}
	for rows.Next() {
		return scanUserTest2Ex(rows)
	}
	return
}

func (t *xUserTest2Operation) DeleteByKey(ctx context.Context, id UserTest2Key) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 del_by_key failed,%w", err)
	}

	return
}

// find by primary key
func (t *xUserTest2Operation) FindByKeyArray(ctx context.Context, ids []UserTest2Key) (datas []*dbop.UserTest2, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := t.FindByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*dbop.UserTest2{data}, nil
	}
	buf := util.Builder{}
	buf.Grow(len(UserTest2SQL_Find) + len(UserTest2SQL_Where1) + (len(ids)-1)*len(UserTest2SQL_Where2))
	buf.Write([]byte(UserTest2SQL_Find))
	buf.Write([]byte(UserTest2SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte(UserTest2SQL_Where2))
	}

	args := make([]any, 0, len(ids)*1)
	for i := 0; i < len(ids); i++ {
		args = append(args, ids[i])
	}
	rows, err := t.db.DB.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 find_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserTest2(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserTest2Operation) FindExByKeyArray(ctx context.Context, ids []UserTest2Key) (datas []*dbop.UserTest2Ex, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := t.FindExByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*dbop.UserTest2Ex{data}, nil
	}
	buf := util.Builder{}
	buf.Grow(len(UserTest2SQL_FindRow) + len(UserTest2SQL_Where1) + (len(ids)-1)*len(UserTest2SQL_Where2))
	buf.Write([]byte(UserTest2SQL_FindRow))
	buf.Write([]byte(UserTest2SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte(UserTest2SQL_Where2))
	}

	args := make([]any, 0, len(ids)*1)
	for i := 0; i < len(ids); i++ {
		args = append(args, ids[i])
	}
	rows, err := t.db.DB.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 findex_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserTest2Ex(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserTest2Operation) DeleteByKeyArray(ctx context.Context, ids []UserTest2Key) (res sql.Result, err error) {
	switch len(ids) {
	case 0:
		return svc_db.EmptyResult{}, nil
	case 1:
		return t.DeleteByKey(ctx, ids[0])
	}
	buf := util.Builder{}
	buf.Grow(len(UserTest2SQL_Delete) + len(UserTest2SQL_Where1) + (len(ids)-1)*len(UserTest2SQL_Where2))
	buf.Write([]byte(UserTest2SQL_Delete))
	buf.Write([]byte(UserTest2SQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte(UserTest2SQL_Where2))
	}

	args := make([]any, 0, len(ids)*1)
	for i := 0; i < len(ids); i++ {
		args = append(args, ids[i])
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 del_by_key_array failed,%w", err)
	}
	return
}

func (t *xUserTest2Operation) FindByIndexUniqueTest(ctx context.Context, uid int64, xxx int64, limit, offset int) (datas []*dbop.UserTest2, err error) {
	if t.idxUniqueTestFind == nil {
		t.idxUniqueTestFind, err = t.db.PrepareContext(ctx, UserTest2SQL_Find+" where `uid`=? and `xxx`=? limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_test_2 find_by_index_unique_test failed,%w", err)
		}
	}
	rows, err := t.idxUniqueTestFind.QueryContext(ctx, UserTest2UidMarshal(uid), xxx, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 find_by_index_unique_test failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserTest2(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserTest2Operation) FindExByIndexUniqueTest(ctx context.Context, uid int64, xxx int64, limit, offset int) (datas []*dbop.UserTest2Ex, err error) {
	if t.idxUniqueTestFindEx == nil {
		t.idxUniqueTestFindEx, err = t.db.PrepareContext(ctx, UserTest2SQL_FindRow+" where `uid`=? and `xxx`=? limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_test_2 findex_by_index_unique_test failed,%w", err)
		}
	}
	rows, err := t.idxUniqueTestFindEx.QueryContext(ctx, UserTest2UidMarshal(uid), xxx, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 findex_by_index_unique_test failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserTest2Ex(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserTest2Operation) CountByIndexUniqueTest(ctx context.Context, uid int64, xxx int64) (count int, err error) {
	if t.idxUniqueTestCount == nil {
		t.idxUniqueTestCount, err = t.db.PrepareContext(ctx, UserTest2SQL_Count+" where `uid`=? and `xxx`=?")
		if err != nil {
			return 0, fmt.Errorf("prepare db_user.user_test_2 count_by_index_unique_test failed,%w", err)
		}
	}
	err = t.idxUniqueTestCount.QueryRowContext(ctx, UserTest2UidMarshal(uid), xxx).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec db_user.user_test_2 count_by_index_unique_test failed,%w", err)
	}
	return
}

func (t *xUserTest2Operation) DeleteByIndexUniqueTest(ctx context.Context, uid int64, xxx int64) (res sql.Result, err error) {
	if t.idxUniqueTestDelete == nil {
		t.idxUniqueTestDelete, err = t.db.PrepareContext(ctx, UserTest2SQL_Delete+" where `uid`=? and `xxx`=?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_test_2 delete_by_index_unique_test failed,%w", err)
		}
	}
	res, err = t.idxUniqueTestDelete.ExecContext(ctx, UserTest2UidMarshal(uid), xxx)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 delete_by_index_unique_test failed,%w", err)
	}
	return
}

func (t *xUserTest2Operation) FindByIndexXxx(ctx context.Context, uid int64, limit, offset int) (datas []*dbop.UserTest2, err error) {
	if t.idxXxxFind == nil {
		t.idxXxxFind, err = t.db.PrepareContext(ctx, UserTest2SQL_Find+" where `uid`=? limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_test_2 find_by_index_xxx failed,%w", err)
		}
	}
	rows, err := t.idxXxxFind.QueryContext(ctx, UserTest2UidMarshal(uid), offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 find_by_index_xxx failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserTest2(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserTest2Operation) FindExByIndexXxx(ctx context.Context, uid int64, limit, offset int) (datas []*dbop.UserTest2Ex, err error) {
	if t.idxXxxFindEx == nil {
		t.idxXxxFindEx, err = t.db.PrepareContext(ctx, UserTest2SQL_FindRow+" where `uid`=? limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_test_2 findex_by_index_xxx failed,%w", err)
		}
	}
	rows, err := t.idxXxxFindEx.QueryContext(ctx, UserTest2UidMarshal(uid), offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 findex_by_index_xxx failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserTest2Ex(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserTest2Operation) CountByIndexXxx(ctx context.Context, uid int64) (count int, err error) {
	if t.idxXxxCount == nil {
		t.idxXxxCount, err = t.db.PrepareContext(ctx, UserTest2SQL_Count+" where `uid`=?")
		if err != nil {
			return 0, fmt.Errorf("prepare db_user.user_test_2 count_by_index_xxx failed,%w", err)
		}
	}
	err = t.idxXxxCount.QueryRowContext(ctx, UserTest2UidMarshal(uid)).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec db_user.user_test_2 count_by_index_xxx failed,%w", err)
	}
	return
}

func (t *xUserTest2Operation) DeleteByIndexXxx(ctx context.Context, uid int64) (res sql.Result, err error) {
	if t.idxXxxDelete == nil {
		t.idxXxxDelete, err = t.db.PrepareContext(ctx, UserTest2SQL_Delete+" where `uid`=?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_test_2 delete_by_index_xxx failed,%w", err)
		}
	}
	res, err = t.idxXxxDelete.ExecContext(ctx, UserTest2UidMarshal(uid))
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 delete_by_index_xxx failed,%w", err)
	}
	return
}

func (t *xUserTest2Operation) Where(bufSize int) *UserTest2WhereStmt {
	w := &UserTest2WhereStmt{}
	w.buf.Grow(bufSize)
	w.buf.Write([]byte(" where "))
	return w
}

func (t *xUserTest2Operation) Select(ctx context.Context, where *UserTest2WhereStmt) (datas []*dbop.UserTest2, err error) {
	var findSql = UserTest2SQL_Find
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	rows, err := t.db.QueryContext(ctx, findSql)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 select failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {

		data, err := scanUserTest2(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserTest2Operation) SelectEx(ctx context.Context, where *UserTest2WhereStmt) (datas []*dbop.UserTest2Ex, err error) {
	var findSql = UserTest2SQL_FindRow
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	rows, err := t.db.QueryContext(ctx, findSql)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 selectex failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserTest2Ex(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserTest2Operation) Count(ctx context.Context, where *UserTest2WhereStmt) (count int, err error) {
	var findSql = UserTest2SQL_Count
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	err = t.db.QueryRowContext(ctx, findSql).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec db_user.user_test_2 count failed,%w", err)
	}
	return
}

func (t *xUserTest2Operation) DeleteMany(ctx context.Context, where *UserTest2WhereStmt) (res sql.Result, err error) {
	var w string
	if where != nil {
		w = where.String()
	}
	buf := util.Builder{}
	buf.Grow(len(UserTest2SQL_Delete) + len(w))
	buf.Write([]byte(UserTest2SQL_Delete))
	buf.WriteString(w)
	res, err = t.db.ExecContext(ctx, buf.String())
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_test_2 delete_many failed,%w", err)
	}

	return
}

func (t *xUserTest2Operation) RangeAll(ctx context.Context, where *UserTest2WhereStmt, f func(ctx context.Context, row *dbop.UserTest2) bool) error {
	var findSql = UserTest2SQL_Find
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	count := 0
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return fmt.Errorf("exec db_user.user_test_2 range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := scanUserTest2(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}

func (t *xUserTest2Operation) RangeAllEx(ctx context.Context, where *UserTest2WhereStmt, f func(ctx context.Context, row *dbop.UserTest2Ex) bool) error {
	var findSql = UserTest2SQL_FindRow
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	count := 0
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return fmt.Errorf("exec db_user.user_test_2 range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := scanUserTest2Ex(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}

func (t *xUserTest2Operation) AllData(ctx context.Context, where *UserTest2WhereStmt) (datas []*dbop.UserTest2, err error) {
	var findSql = UserTest2SQL_Find
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	datas = make([]*dbop.UserTest2, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return nil, fmt.Errorf("exec db_user.user_test_2 all_data failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := scanUserTest2(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}

func (t *xUserTest2Operation) AllDataEx(ctx context.Context, where *UserTest2WhereStmt) (datas []*dbop.UserTest2Ex, err error) {
	var findSql = UserTest2SQL_FindRow
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	datas = make([]*dbop.UserTest2Ex, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return nil, fmt.Errorf("exec db_user.user_test_2 all_data_ex failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := scanUserTest2Ex(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}

func (t *xUserTest2Operation) DB() *sqlx.DB {
	return t.db
}

////////////////////////////////////////////////////////////////////////////////
// where stmt

type UserTest2WhereStmt struct {
	buf           util.Builder
	limit, offset int
}

func (w *UserTest2WhereStmt) Uid() *svc_db.IntSignedCondition[UserTest2WhereStmt, int64] {
	return svc_db.NewIntSignedCondition[UserTest2WhereStmt, int64](w, &w.buf, "uid")
}

func (w *UserTest2WhereStmt) Xxx() *svc_db.IntSignedCondition[UserTest2WhereStmt, int64] {
	return svc_db.NewIntSignedCondition[UserTest2WhereStmt, int64](w, &w.buf, "xxx")
}

func (w *UserTest2WhereStmt) State() *svc_db.IntSignedCondition[UserTest2WhereStmt, int8] {
	return svc_db.NewIntSignedCondition[UserTest2WhereStmt, int8](w, &w.buf, "state")
}

func (w *UserTest2WhereStmt) CustomVal() *svc_db.StringCondition[UserTest2WhereStmt] {
	return svc_db.NewStringCondition[UserTest2WhereStmt](w, &w.buf, "custom_val")
}

func (w *UserTest2WhereStmt) Limit(limit, offset int) *UserTest2WhereStmt {
	w.limit = limit
	w.offset = offset
	return w
}

func (w *UserTest2WhereStmt) And() *UserTest2WhereStmt {
	w.buf.Write([]byte(" and "))
	return w
}

func (w *UserTest2WhereStmt) Or() *UserTest2WhereStmt {
	w.buf.Write([]byte(" or "))
	return w
}

func (w *UserTest2WhereStmt) Group(gf func(w *UserTest2WhereStmt)) *UserTest2WhereStmt {
	w.buf.WriteByte('(')
	gf(w)
	w.buf.WriteByte(')')
	return w
}

func (w *UserTest2WhereStmt) Custom(f func(buf *util.Builder)) *UserTest2WhereStmt {
	f(&w.buf)
	return w
}

func (w *UserTest2WhereStmt) applyLimitAndOffset() {
	if w.limit == 0 && w.offset == 0 {
		return
	}
	w.buf.Write([]byte(" limit "))
	w.buf.WriteInt(w.offset)
	w.buf.WriteByte(',')
	w.buf.WriteInt(w.limit)
}

func (w *UserTest2WhereStmt) String() string {
	return w.buf.String()
}

////////////////////////////////////////////////////////////////////////////////
// scan interface

func scanUserTest2(rows *sql.Rows) (data *dbop.UserTest2, err error) {
	var values [4]sql.RawBytes
	err = rows.Scan(&values[0], &values[1], &values[2], &values[3])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan failed, %w", err)
	}

	data = &dbop.UserTest2{}
	data.Uid, err = UserTest2UidUnamrshal(values[0])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan uid failed, %w", err)
	}
	data.Xxx, err = UserTest2XxxUnamrshal(values[1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan xxx failed, %w", err)
	}
	data.State, err = UserTest2StateUnamrshal(values[2])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan state failed, %w", err)
	}
	data.CustomVal, err = UserTest2CustomValUnamrshal(values[3])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan custom_val failed, %w", err)
	}
	return data, nil
}

func scanUserTest2Ex(rows *sql.Rows) (data *dbop.UserTest2Ex, err error) {
	var values [4 + 2]sql.RawBytes
	err = rows.Scan(&values[0], &values[1], &values[2], &values[3], &values[4], &values[4+1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan_ex failed, %w", err)
	}

	data = &dbop.UserTest2Ex{}
	data.Uid, err = UserTest2UidUnamrshal(values[0])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan_ex uid failed, %w", err)
	}
	data.Xxx, err = UserTest2XxxUnamrshal(values[1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan_ex xxx failed, %w", err)
	}
	data.State, err = UserTest2StateUnamrshal(values[2])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan_ex state failed, %w", err)
	}
	data.CustomVal, err = UserTest2CustomValUnamrshal(values[3])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan_ex custom_val failed, %w", err)
	}
	data.ModifyStamp, err = svc_db.RawToStampInt64(values[4])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan_ex modify_stamp failed, %w", err)
	}
	data.CreateStamp, err = svc_db.RawToStampInt64(values[4+1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_test_2 scan_ex create_stamp failed, %w", err)
	}
	return data, nil
}

////////////////////////////////////////////////////////////////////////////////
// named sql

type UserTest2SQLWriter struct {
	buf util.Builder
}

func (x *UserTest2SQLWriter) Select() *UserTest2NamedSelect {
	x.buf.Write([]byte("select "))
	var v int
	return &UserTest2NamedSelect{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *UserTest2SQLWriter) Update() *UserTest2NamedUpdate {
	x.buf.Write([]byte("update user_test_2 set "))
	var v int
	return &UserTest2NamedUpdate{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *UserTest2SQLWriter) Insert() *UserTest2NamedInsert {
	return &UserTest2NamedInsert{
		buf: &x.buf,
	}
}

func (x *UserTest2SQLWriter) Delete() *UserTest2NamedWhere {
	x.buf.Write([]byte("delete from user_test_2 where "))
	return &UserTest2NamedWhere{
		buf: &x.buf,
	}
}

type UserTest2NamedInsert struct {
	buf          *util.Builder
	list, values []string
}

func (x *UserTest2NamedInsert) Uid() *UserTest2NamedInsert {
	x.list = append(x.list, "`uid`")
	x.values = append(x.values, ":uid")
	return x
}

func (x *UserTest2NamedInsert) Xxx() *UserTest2NamedInsert {
	x.list = append(x.list, "`xxx`")
	x.values = append(x.values, ":xxx")
	return x
}

func (x *UserTest2NamedInsert) State() *UserTest2NamedInsert {
	x.list = append(x.list, "`state`")
	x.values = append(x.values, ":state")
	return x
}

func (x *UserTest2NamedInsert) CustomVal() *UserTest2NamedInsert {
	x.list = append(x.list, "`custom_val`")
	x.values = append(x.values, ":custom_val")
	return x
}

func (x *UserTest2NamedInsert) ModifyStamp() *UserTest2NamedInsert {
	x.list = append(x.list, "`modify_stamp`")
	x.values = append(x.values, ":modify_stamp")
	return x
}

func (x *UserTest2NamedInsert) CreateStamp() *UserTest2NamedInsert {
	x.list = append(x.list, "`create_stamp`")
	x.values = append(x.values, ":create_stamp")
	return x
}

func (x *UserTest2NamedInsert) ToSQL() string {
	x.buf.Write([]byte("insert user_test_2("))
	x.buf.WriteString(strings.Join(x.list, ","))
	x.buf.Write([]byte(") values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

func (x *UserTest2NamedInsert) ValuesToSQL() string {
	x.buf.Write([]byte(",values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

type UserTest2NamedUpdate struct {
	buf    *util.Builder
	n      *int
	values *bool
}

func (x *UserTest2NamedUpdate) Uid() *UserTest2NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`uid`=values(`uid`)"))
	} else {
		x.buf.Write([]byte("`uid`=:uid"))
	}
	*x.n++
	return x
}

func (x *UserTest2NamedUpdate) Xxx() *UserTest2NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`xxx`=values(`xxx`)"))
	} else {
		x.buf.Write([]byte("`xxx`=:xxx"))
	}
	*x.n++
	return x
}

func (x *UserTest2NamedUpdate) State() *UserTest2NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`state`=values(`state`)"))
	} else {
		x.buf.Write([]byte("`state`=:state"))
	}
	*x.n++
	return x
}

func (x *UserTest2NamedUpdate) CustomVal() *UserTest2NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`custom_val`=values(`custom_val`)"))
	} else {
		x.buf.Write([]byte("`custom_val`=:custom_val"))
	}
	*x.n++
	return x
}

func (x *UserTest2NamedUpdate) ModifyStamp() *UserTest2NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`modify_stamp`=values(`modify_stamp`)"))
	} else {
		x.buf.Write([]byte("`modify_stamp`=:modify_stamp"))
	}
	*x.n++
	return x
}

func (x *UserTest2NamedUpdate) CreateStamp() *UserTest2NamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`create_stamp`=values(`create_stamp`)"))
	} else {
		x.buf.Write([]byte("`create_stamp`=:create_stamp"))
	}
	*x.n++
	return x
}

func (x *UserTest2NamedUpdate) Where() *UserTest2NamedWhere {
	if x.values != nil {
		panic("invalid where")
	}
	x.buf.Write([]byte(" where "))
	return &UserTest2NamedWhere{
		buf: x.buf,
	}
}

func (x *UserTest2NamedUpdate) ToSQL() string {
	return x.buf.String()
}

type UserTest2NamedSelect struct {
	buf *util.Builder
	n   *int
}

func (x *UserTest2NamedSelect) Uid() *UserTest2NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`uid`"))
	*x.n++
	return x
}

func (x *UserTest2NamedSelect) Xxx() *UserTest2NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`xxx`"))
	*x.n++
	return x
}

func (x *UserTest2NamedSelect) State() *UserTest2NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`state`"))
	*x.n++
	return x
}

func (x *UserTest2NamedSelect) CustomVal() *UserTest2NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`custom_val`"))
	*x.n++
	return x
}

func (x *UserTest2NamedSelect) ModifyStamp() *UserTest2NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`modify_stamp`"))
	*x.n++
	return x
}

func (x *UserTest2NamedSelect) CreateStamp() *UserTest2NamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`create_stamp`"))
	*x.n++
	return x
}

func (x *UserTest2NamedSelect) Where() *UserTest2NamedWhere {
	x.buf.Write([]byte(" from user_test_2 where "))
	return &UserTest2NamedWhere{
		buf: x.buf,
	}
}

func (x *UserTest2NamedSelect) ToSQL() string {
	x.buf.Write([]byte(" from user_test_2"))
	return x.buf.String()
}

type UserTest2NamedWhere struct {
	buf *util.Builder
}

func (x *UserTest2NamedWhere) Uid() *UserTest2NamedWhere {
	x.buf.Write([]byte("`uid` = :uid"))
	return x
}

func (x *UserTest2NamedWhere) Xxx() *UserTest2NamedWhere {
	x.buf.Write([]byte("`xxx` = :xxx"))
	return x
}

func (x *UserTest2NamedWhere) State() *UserTest2NamedWhere {
	x.buf.Write([]byte("`state` = :state"))
	return x
}

func (x *UserTest2NamedWhere) CustomVal() *UserTest2NamedWhere {
	x.buf.Write([]byte("`custom_val` = :custom_val"))
	return x
}

func (x *UserTest2NamedWhere) ModifyStamp() *UserTest2NamedWhere {
	x.buf.Write([]byte("`modify_stamp` = :modify_stamp"))
	return x
}

func (x *UserTest2NamedWhere) CreateStamp() *UserTest2NamedWhere {
	x.buf.Write([]byte("`create_stamp` = :create_stamp"))
	return x
}

func (x *UserTest2NamedWhere) Limit(limit, offset int) *UserTest2NamedWhere {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *UserTest2NamedWhere) And() *UserTest2NamedWhere {
	x.buf.Write([]byte(" and "))
	return x
}

func (x *UserTest2NamedWhere) Or() *UserTest2NamedWhere {
	x.buf.Write([]byte(" or "))
	return x
}

func (x *UserTest2NamedWhere) Group(gf func(w *UserTest2NamedWhere)) *UserTest2NamedWhere {
	x.buf.WriteByte('(')
	gf(x)
	x.buf.WriteByte(')')
	return x
}

func (x *UserTest2NamedWhere) Custom(f func(buf *util.Builder)) *UserTest2NamedWhere {
	f(x.buf)
	return x
}

func (x *UserTest2NamedWhere) OnDuplicateKeyUpdate() *UserTest2NamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := false
	return &UserTest2NamedUpdate{
		buf:    x.buf,
		n:      &v,
		values: &values,
	}
}

func (x *UserTest2NamedWhere) OnDuplicateKeyUpdateValues() *UserTest2NamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := true
	return &UserTest2NamedUpdate{
		buf:    x.buf,
		n:      &v,
		values: &values,
	}
}

func (x *UserTest2NamedWhere) ToSQL() string {
	return x.buf.String()
}

func (x *UserTest2NamedWhere) OrderBy() *UserTest2NamedOrderBy {
	x.buf.Write([]byte(" order by "))
	var v int
	return &UserTest2NamedOrderBy{
		buf: x.buf,
		n:   &v,
	}
}

type UserTest2NamedOrderBy struct {
	buf *util.Builder
	n   *int
}

func (x *UserTest2NamedOrderBy) Uid() *UserTest2NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`uid`"))
	*x.n++
	return &UserTest2NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserTest2NamedOrderBy) Xxx() *UserTest2NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`xxx`"))
	*x.n++
	return &UserTest2NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserTest2NamedOrderBy) State() *UserTest2NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`state`"))
	*x.n++
	return &UserTest2NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserTest2NamedOrderBy) CustomVal() *UserTest2NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`custom_val`"))
	*x.n++
	return &UserTest2NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserTest2NamedOrderAsc) ModifyStamp() *UserTest2NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`modify_stamp`"))
	*x.n++
	return &UserTest2NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserTest2NamedOrderAsc) CreateStamp() *UserTest2NamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`create_stamp`"))
	*x.n++
	return &UserTest2NamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserTest2NamedOrderBy) Limit(limit, offset int) *UserTest2NamedOrderBy {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *UserTest2NamedOrderBy) ToSQL() string {
	return x.buf.String()
}

type UserTest2NamedOrderAsc struct {
	buf *util.Builder
	n   *int
}

func (x *UserTest2NamedOrderAsc) Asc() *UserTest2NamedOrderBy {
	x.buf.Write([]byte(" asc "))
	return &UserTest2NamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserTest2NamedOrderAsc) Desc() *UserTest2NamedOrderBy {
	x.buf.Write([]byte(" desc "))
	return &UserTest2NamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserTest2NamedOrderAsc) ToSQL() string {
	return x.buf.String()
}
