// Code generated by wpb. DO NOT EDIT.
package db_user

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"sync/atomic"

	"github.com/jmoiron/sqlx"
	"github.com/walleframe/svc_db"
	"github.com/walleframe/svc_db/example/dbop"
	"github.com/walleframe/walle/util"
)

////////////////////////////////////////////////////////////////////////////////
// public interface

type UserInfoKey = int64

type UserInfoOperation interface {
	Insert(ctx context.Context, data *dbop.UserInfo) (res sql.Result, err error)
	InsertMany(ctx context.Context, datas []*dbop.UserInfo) (res sql.Result, err error)

	Update(ctx context.Context, data *dbop.UserInfo) (res sql.Result, err error)
	Upsert(ctx context.Context, data *dbop.UserInfo) (res sql.Result, err error)
	UpsertMany(ctx context.Context, datas []*dbop.UserInfo) (res sql.Result, err error)

	Find(ctx context.Context, uid int64) (data *dbop.UserInfo, err error)
	FindEx(ctx context.Context, uid int64) (data *dbop.UserInfoEx, err error)
	Delete(ctx context.Context, uid int64) (res sql.Result, err error)

	FindByKey(ctx context.Context, id UserInfoKey) (data *dbop.UserInfo, err error)
	FindExByKey(ctx context.Context, id UserInfoKey) (data *dbop.UserInfoEx, err error)
	DeleteByKey(ctx context.Context, id UserInfoKey) (res sql.Result, err error)

	FindByKeyArray(ctx context.Context, ids []UserInfoKey) (datas []*dbop.UserInfo, err error)
	FindExByKeyArray(ctx context.Context, ids []UserInfoKey) (datas []*dbop.UserInfoEx, err error)
	DeleteByKeyArray(ctx context.Context, ids []UserInfoKey) (res sql.Result, err error)

	FindByIndexEmail(ctx context.Context, email string, limit, offset int) (datas []*dbop.UserInfo, err error)
	FindExByIndexEmail(ctx context.Context, email string, limit, offset int) (datas []*dbop.UserInfoEx, err error)
	CountByIndexEmail(ctx context.Context, email string) (count int, err error)
	DeleteByIndexEmail(ctx context.Context, email string) (res sql.Result, err error)

	FindByIndexName(ctx context.Context, name string, limit, offset int) (datas []*dbop.UserInfo, err error)
	FindExByIndexName(ctx context.Context, name string, limit, offset int) (datas []*dbop.UserInfoEx, err error)
	CountByIndexName(ctx context.Context, name string) (count int, err error)
	DeleteByIndexName(ctx context.Context, name string) (res sql.Result, err error)

	Where(bufSize int) *UserInfoWhereStmt
	Select(ctx context.Context, where *UserInfoWhereStmt) (datas []*dbop.UserInfo, err error)
	SelectEx(ctx context.Context, where *UserInfoWhereStmt) (datas []*dbop.UserInfoEx, err error)
	Count(ctx context.Context, where *UserInfoWhereStmt) (count int, err error)

	DeleteMany(ctx context.Context, where *UserInfoWhereStmt) (res sql.Result, err error)

	RangeAll(ctx context.Context, where *UserInfoWhereStmt, f func(ctx context.Context, row *dbop.UserInfo) bool) error
	RangeAllEx(ctx context.Context, where *UserInfoWhereStmt, f func(ctx context.Context, row *dbop.UserInfoEx) bool) error
	AllData(ctx context.Context, where *UserInfoWhereStmt) (datas []*dbop.UserInfo, err error)
	AllDataEx(ctx context.Context, where *UserInfoWhereStmt) (datas []*dbop.UserInfoEx, err error)

	// use for custom named sql
	DB() *sqlx.DB
}

var (
	UserInfoUidUnamrshal   = svc_db.RawToInt64
	UserInfoNameUnamrshal  = svc_db.RawToString
	UserInfoEmailUnamrshal = svc_db.RawToString
)

var (
	globalUserInfoOP atomic.Pointer[xUserInfoOperation]
)

func init() {
	svc_db.RegisterSyncDBTable("mysql", "db_user", "user_info", SyncUserInfoDBTable)
	svc_db.RegisterDB("mysql", "db_user", "user_info", func(db *sqlx.DB) error {
		//
		err := SyncUserInfoDBTable(context.Background(), db)
		if err != nil {
			return fmt.Errorf("swap db_user.user_info pointer, %w", err)
		}
		//
		tableOP, err := NewUserInfoOperation(db)
		if err != nil {
			return fmt.Errorf("swap db_user.user_info pointer, new table operation failed, %w", err)
		}

		globalUserInfoOP.Store(tableOP)
		return nil
	})
}

var UserInfoOP = func() UserInfoOperation {
	return globalUserInfoOP.Load()
}

func UserInfoNamedSQL(bufSize int) *UserInfoSQLWriter {
	sql := &UserInfoSQLWriter{}
	sql.buf.Grow(bufSize)
	return sql
}

func SyncUserInfoDBTable(ctx context.Context, db *sqlx.DB) (err error) {
	// sync table columns
	err = svc_db.SyncTableColumns(context.Background(), db, "user_info", UserInfoSQL_Create, UserInfoSQL_TableColumns)
	if err != nil {
		return fmt.Errorf("sync db_user.user_info table, sync columns failed, %w", err)
	}
	// sync table index
	err = svc_db.SyncTableIndex(context.Background(), db, "user_info", UserInfoSQL_TableIndex)
	if err != nil {
		return fmt.Errorf("sync db_user.user_info table, sync index failed, %w", err)
	}
	return
}

func UserInfoToPrimaryKeys(rows []*dbop.UserInfo) (ids []UserInfoKey) {
	ids = make([]UserInfoKey, 0, len(rows))
	for _, v := range rows {
		ids = append(ids, v.Uid)
	}
	return
}

func UserInfoExToPrimaryKeysEx(rows []*dbop.UserInfoEx) (ids []UserInfoKey) {
	ids = make([]UserInfoKey, 0, len(rows))
	for _, v := range rows {
		ids = append(ids, v.Uid)
	}
	return
}

////////////////////////////////////////////////////////////////////////////////
// sql statement

const (
	UserInfoSQL_Insert        = "insert user_info(`name`,`email`) values(?,?)"
	UserInfoSQL_Insert2       = "insert user_info(`uid`,`name`,`email`) values(?,?,?)"
	UserInfoSQL_InsertValues  = ",(?,?)"
	UserInfoSQL_InsertValues2 = ",(?,?,?)"
	UserInfoSQL_Where1        = " where (`uid`=?)"
	UserInfoSQL_Where2        = " or (`uid`=?)"
	UserInfoSQL_Upsert        = "insert user_info(`uid`,`name`,`email`) values(?,?,?)"
	UserInfoSQL_UpsertUpdate  = " on duplicate key update `name`=values(`name`),`email`=values(`email`)"
	UserInfoSQL_Update        = "update user_info set `name`=?,`email`=? where `uid`=?"
	UserInfoSQL_Delete        = "delete from user_info"
	UserInfoSQL_Find          = "select `uid`,`name`,`email` from user_info"
	UserInfoSQL_FindRow       = "select `uid`,`name`,`email`,`modify_stamp`,`create_stamp` from user_info"
	UserInfoSQL_Count         = "select count(*) from user_info"
	UserInfoSQL_Create        = "create table user_info (" +
		"`uid` bigint not null auto_increment," +
		"`name` varchar(128) not null default ''," +
		"`email` varchar(64) not null default ''," +
		"`modify_stamp` timestamp default current_timestamp on update current_timestamp," +
		"`create_stamp` timestamp default current_timestamp" + "," +
		"PRIMARY KEY ( `uid`)" +
		") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;"
)

var (
	UserInfoSQL_TableColumns = map[string]string{
		"uid":   "alter table user_info add `uid` bigint not null auto_increment;",
		"name":  "alter table user_info add `name` varchar(128) not null default '';",
		"email": "alter table user_info add `email` varchar(64) not null default '';",
	}
	UserInfoSQL_TableIndex = map[string]string{
		"user_info_email": "create index user_info_email on user_info(`email`)",
		"user_info_name":  "create unique index user_info_name on user_info(`name`)",
	}
)

////////////////////////////////////////////////////////////////////////////////
// TblTestOperation impl

type xUserInfoOperation struct {
	db             *sqlx.DB
	insert         *sql.Stmt
	insert2        *sql.Stmt // increment id
	update         *sql.Stmt
	upsert         *sql.Stmt
	delete         *sql.Stmt
	find           *sql.Stmt
	findRow        *sql.Stmt
	idxEmailFind   *sql.Stmt
	idxEmailFindEx *sql.Stmt
	idxEmailCount  *sql.Stmt
	idxEmailDelete *sql.Stmt
	idxNameFind    *sql.Stmt
	idxNameFindEx  *sql.Stmt
	idxNameCount   *sql.Stmt
	idxNameDelete  *sql.Stmt
}

func NewUserInfoOperation(db *sqlx.DB) (_ *xUserInfoOperation, err error) {
	t := &xUserInfoOperation{
		db: db,
	}

	t.insert, err = db.Prepare(UserInfoSQL_Insert)
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_info insert failed,%w", err)
	}
	t.insert2, err = db.Prepare(UserInfoSQL_Insert2)
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_info insert2 failed,%w", err)
	}
	t.update, err = db.Prepare(UserInfoSQL_Update)
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_info update failed,%w", err)
	}
	t.upsert, err = db.Prepare(UserInfoSQL_Upsert + UserInfoSQL_UpsertUpdate)
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_info upsert failed,%w", err)
	}
	t.delete, err = db.Prepare(UserInfoSQL_Delete + " where `uid`=?")
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_info delete failed,%w", err)
	}
	t.find, err = db.Prepare(UserInfoSQL_Find + " where `uid`=?")
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_info find failed,%w", err)
	}
	t.findRow, err = db.Prepare(UserInfoSQL_FindRow + " where `uid`=?")
	if err != nil {
		return nil, fmt.Errorf("prepare db_user.user_info findex failed,%w", err)
	}

	return t, nil
}

func (t *xUserInfoOperation) Insert(ctx context.Context, data *dbop.UserInfo) (res sql.Result, err error) {
	// auto increment field
	if data.Uid != 0 {
		res, err = t.insert2.ExecContext(ctx, data.Uid, data.Name, data.Email)
	} else {
		res, err = t.insert.ExecContext(ctx, data.Name, data.Email)
	}
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info insert failed,%w", err)
	}

	return
}

func (t *xUserInfoOperation) InsertMany(ctx context.Context, datas []*dbop.UserInfo) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return svc_db.EmptyResult{}, nil
	case 1:
		return t.Insert(ctx, datas[0])
	}

	// auto increment field
	withID := datas[0].Uid != 0
	// 必须都设置了 incr id 或者都没有设置 incr.
	for i := 1; i < len(datas); i++ {
		if withID != (datas[i].Uid != 0) {
			return nil, fmt.Errorf("exec db_user.user_info check failed, auto increment field not match. frist:%t %d:%t", withID, i, !withID)
		}
	}
	if withID {
		buf := util.Builder{}
		buf.Grow(len(UserInfoSQL_Insert2) + (len(datas)-1)*len(UserInfoSQL_InsertValues2))
		buf.Write([]byte(UserInfoSQL_Insert2))
		for i := 0; i < len(datas)-1; i++ {
			buf.Write([]byte(UserInfoSQL_InsertValues2))
		}
		args := make([]any, 0, len(datas)*3)
		for i := 0; i < len(datas); i++ {
			data := datas[i]
			args = append(args, data.Uid, data.Name, data.Email)
		}
		res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
		if err != nil {
			return nil, fmt.Errorf("exec db_user.user_info insert_many withid failed,%w", err)
		}
		return
	}

	buf := util.Builder{}
	buf.Grow(len(UserInfoSQL_Insert) + (len(datas)-1)*len(UserInfoSQL_InsertValues))
	buf.Write([]byte(UserInfoSQL_Insert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte(UserInfoSQL_InsertValues))
	}
	args := make([]any, 0, len(datas)*2)
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, data.Name, data.Email)
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info insert_many failed,%w", err)
	}
	return
}

func (t *xUserInfoOperation) Update(ctx context.Context, data *dbop.UserInfo) (res sql.Result, err error) {
	// auto increment field
	if data.Uid == 0 {
		return nil, errors.New("update user_info not set primary key")
	}
	res, err = t.update.ExecContext(ctx, data.Name, data.Email, data.Uid)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info update failed,%w", err)
	}

	return
}

func (t *xUserInfoOperation) Upsert(ctx context.Context, data *dbop.UserInfo) (res sql.Result, err error) {
	// auto increment field
	if data.Uid == 0 {
		return t.Insert(ctx, data)
	}

	res, err = t.upsert.ExecContext(ctx, data.Uid, data.Name, data.Email)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info upsert failed,%w", err)
	}

	return
}

func (t *xUserInfoOperation) UpsertMany(ctx context.Context, datas []*dbop.UserInfo) (res sql.Result, err error) {
	switch len(datas) {
	case 0:
		return svc_db.EmptyResult{}, nil
	case 1:
		return t.Upsert(ctx, datas[0])
	}

	// auto increment field
	for i := 1; i < len(datas); i++ {
		if datas[i].Uid == 0 {
			return nil, errors.New("exec db_user.user_info upsert_many check not set incr id")
		}
	}

	buf := util.Builder{}
	buf.Grow(len(UserInfoSQL_Upsert) + (len(datas)-1)*len(UserInfoSQL_InsertValues2) + len(UserInfoSQL_UpsertUpdate))
	buf.Write([]byte(UserInfoSQL_Upsert))
	for i := 0; i < len(datas)-1; i++ {
		buf.Write([]byte(UserInfoSQL_InsertValues2))
	}
	buf.Write([]byte(UserInfoSQL_UpsertUpdate))
	args := make([]any, 0, len(datas)*3)
	for i := 0; i < len(datas); i++ {
		data := datas[i]
		args = append(args, data.Uid, data.Name, data.Email)
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info upsert_many failed,%w", err)
	}
	return
}

// find by primary key
func (t *xUserInfoOperation) Find(ctx context.Context, uid int64) (data *dbop.UserInfo, err error) {
	rows, err := t.find.QueryContext(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info find failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return scanUserInfo(rows)
	}
	return
}

func (t *xUserInfoOperation) FindEx(ctx context.Context, uid int64) (data *dbop.UserInfoEx, err error) {
	rows, err := t.findRow.QueryContext(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info findex failed,%w", err)
	}
	defer rows.Close()
	for rows.Next() {
		return scanUserInfoEx(rows)
	}
	return
}

func (t *xUserInfoOperation) Delete(ctx context.Context, uid int64) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, uid)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info delete failed,%w", err)
	}

	return
}

// find by primary key
func (t *xUserInfoOperation) FindByKey(ctx context.Context, id UserInfoKey) (data *dbop.UserInfo, err error) {
	rows, err := t.find.QueryContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info find_by_key failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		return scanUserInfo(rows)
	}
	return
}

func (t *xUserInfoOperation) FindExByKey(ctx context.Context, id UserInfoKey) (data *dbop.UserInfoEx, err error) {
	rows, err := t.findRow.QueryContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info findex_by_key failed,%w", err)
	}
	defer rows.Close()
	data = &dbop.UserInfoEx{}
	for rows.Next() {
		return scanUserInfoEx(rows)
	}
	return
}

func (t *xUserInfoOperation) DeleteByKey(ctx context.Context, id UserInfoKey) (res sql.Result, err error) {
	res, err = t.delete.ExecContext(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info del_by_key failed,%w", err)
	}

	return
}

// find by primary key
func (t *xUserInfoOperation) FindByKeyArray(ctx context.Context, ids []UserInfoKey) (datas []*dbop.UserInfo, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := t.FindByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*dbop.UserInfo{data}, nil
	}
	buf := util.Builder{}
	buf.Grow(len(UserInfoSQL_Find) + len(UserInfoSQL_Where1) + (len(ids)-1)*len(UserInfoSQL_Where2))
	buf.Write([]byte(UserInfoSQL_Find))
	buf.Write([]byte(UserInfoSQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte(UserInfoSQL_Where2))
	}

	args := make([]any, 0, len(ids)*1)
	for i := 0; i < len(ids); i++ {
		args = append(args, ids[i])
	}
	rows, err := t.db.DB.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info find_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserInfo(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserInfoOperation) FindExByKeyArray(ctx context.Context, ids []UserInfoKey) (datas []*dbop.UserInfoEx, err error) {
	switch len(ids) {
	case 0:
		return nil, nil
	case 1:
		data, err := t.FindExByKey(ctx, ids[0])
		if err != nil {
			return nil, err
		}
		return []*dbop.UserInfoEx{data}, nil
	}
	buf := util.Builder{}
	buf.Grow(len(UserInfoSQL_FindRow) + len(UserInfoSQL_Where1) + (len(ids)-1)*len(UserInfoSQL_Where2))
	buf.Write([]byte(UserInfoSQL_FindRow))
	buf.Write([]byte(UserInfoSQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte(UserInfoSQL_Where2))
	}

	args := make([]any, 0, len(ids)*1)
	for i := 0; i < len(ids); i++ {
		args = append(args, ids[i])
	}
	rows, err := t.db.DB.QueryContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info findex_by_key_array failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserInfoEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserInfoOperation) DeleteByKeyArray(ctx context.Context, ids []UserInfoKey) (res sql.Result, err error) {
	switch len(ids) {
	case 0:
		return svc_db.EmptyResult{}, nil
	case 1:
		return t.DeleteByKey(ctx, ids[0])
	}
	buf := util.Builder{}
	buf.Grow(len(UserInfoSQL_Delete) + len(UserInfoSQL_Where1) + (len(ids)-1)*len(UserInfoSQL_Where2))
	buf.Write([]byte(UserInfoSQL_Delete))
	buf.Write([]byte(UserInfoSQL_Where1))
	for i := 0; i < len(ids)-1; i++ {
		buf.Write([]byte(UserInfoSQL_Where2))
	}

	args := make([]any, 0, len(ids)*1)
	for i := 0; i < len(ids); i++ {
		args = append(args, ids[i])
	}
	res, err = t.db.DB.ExecContext(ctx, buf.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info del_by_key_array failed,%w", err)
	}
	return
}

func (t *xUserInfoOperation) FindByIndexEmail(ctx context.Context, email string, limit, offset int) (datas []*dbop.UserInfo, err error) {
	if t.idxEmailFind == nil {
		t.idxEmailFind, err = t.db.PrepareContext(ctx, UserInfoSQL_Find+" where `email`=? limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_info find_by_index_email failed,%w", err)
		}
	}
	rows, err := t.idxEmailFind.QueryContext(ctx, email, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info find_by_index_email failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserInfo(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
func (t *xUserInfoOperation) FindExByIndexEmail(ctx context.Context, email string, limit, offset int) (datas []*dbop.UserInfoEx, err error) {
	if t.idxEmailFindEx == nil {
		t.idxEmailFindEx, err = t.db.PrepareContext(ctx, UserInfoSQL_FindRow+" where `email`=? limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_info findex_by_index_email failed,%w", err)
		}
	}
	rows, err := t.idxEmailFindEx.QueryContext(ctx, email, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info findex_by_index_email failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserInfoEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
func (t *xUserInfoOperation) CountByIndexEmail(ctx context.Context, email string) (count int, err error) {
	if t.idxEmailCount == nil {
		t.idxEmailCount, err = t.db.PrepareContext(ctx, UserInfoSQL_Count+" where `email`=?")
		if err != nil {
			return 0, fmt.Errorf("prepare db_user.user_info count_by_index_email failed,%w", err)
		}
	}
	err = t.idxEmailCount.QueryRowContext(ctx, email).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec db_user.user_info count_by_index_email failed,%w", err)
	}
	return
}

func (t *xUserInfoOperation) DeleteByIndexEmail(ctx context.Context, email string) (res sql.Result, err error) {
	if t.idxEmailDelete == nil {
		t.idxEmailDelete, err = t.db.PrepareContext(ctx, UserInfoSQL_Delete+" where `email`=?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_info delete_by_index_email failed,%w", err)
		}
	}
	res, err = t.idxEmailDelete.ExecContext(ctx, email)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info delete_by_index_email failed,%w", err)
	}
	return
}

func (t *xUserInfoOperation) FindByIndexName(ctx context.Context, name string, limit, offset int) (datas []*dbop.UserInfo, err error) {
	if t.idxNameFind == nil {
		t.idxNameFind, err = t.db.PrepareContext(ctx, UserInfoSQL_Find+" where `name`=? limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_info find_by_index_name failed,%w", err)
		}
	}
	rows, err := t.idxNameFind.QueryContext(ctx, name, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info find_by_index_name failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserInfo(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
func (t *xUserInfoOperation) FindExByIndexName(ctx context.Context, name string, limit, offset int) (datas []*dbop.UserInfoEx, err error) {
	if t.idxNameFindEx == nil {
		t.idxNameFindEx, err = t.db.PrepareContext(ctx, UserInfoSQL_FindRow+" where `name`=? limit ?,?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_info findex_by_index_name failed,%w", err)
		}
	}
	rows, err := t.idxNameFindEx.QueryContext(ctx, name, offset, limit)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info findex_by_index_name failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserInfoEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}
func (t *xUserInfoOperation) CountByIndexName(ctx context.Context, name string) (count int, err error) {
	if t.idxNameCount == nil {
		t.idxNameCount, err = t.db.PrepareContext(ctx, UserInfoSQL_Count+" where `name`=?")
		if err != nil {
			return 0, fmt.Errorf("prepare db_user.user_info count_by_index_name failed,%w", err)
		}
	}
	err = t.idxNameCount.QueryRowContext(ctx, name).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec db_user.user_info count_by_index_name failed,%w", err)
	}
	return
}

func (t *xUserInfoOperation) DeleteByIndexName(ctx context.Context, name string) (res sql.Result, err error) {
	if t.idxNameDelete == nil {
		t.idxNameDelete, err = t.db.PrepareContext(ctx, UserInfoSQL_Delete+" where `name`=?")
		if err != nil {
			return nil, fmt.Errorf("prepare db_user.user_info delete_by_index_name failed,%w", err)
		}
	}
	res, err = t.idxNameDelete.ExecContext(ctx, name)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info delete_by_index_name failed,%w", err)
	}
	return
}

func (t *xUserInfoOperation) Where(bufSize int) *UserInfoWhereStmt {
	w := &UserInfoWhereStmt{}
	w.buf.Grow(bufSize)
	w.buf.Write([]byte(" where "))
	return w
}

func (t *xUserInfoOperation) Select(ctx context.Context, where *UserInfoWhereStmt) (datas []*dbop.UserInfo, err error) {
	var findSql = UserInfoSQL_Find
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	rows, err := t.db.QueryContext(ctx, findSql)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info select failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {

		data, err := scanUserInfo(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserInfoOperation) SelectEx(ctx context.Context, where *UserInfoWhereStmt) (datas []*dbop.UserInfoEx, err error) {
	var findSql = UserInfoSQL_FindRow
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	rows, err := t.db.QueryContext(ctx, findSql)
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info selectex failed,%w", err)
	}
	defer rows.Close()

	for rows.Next() {
		data, err := scanUserInfoEx(rows)
		if err != nil {
			return nil, err
		}
		datas = append(datas, data)
	}
	return
}

func (t *xUserInfoOperation) Count(ctx context.Context, where *UserInfoWhereStmt) (count int, err error) {
	var findSql = UserInfoSQL_Count
	if where != nil {
		where.applyLimitAndOffset()
		findSql += where.String()
	}
	err = t.db.QueryRowContext(ctx, findSql).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("exec db_user.user_info count failed,%w", err)
	}
	return
}

func (t *xUserInfoOperation) DeleteMany(ctx context.Context, where *UserInfoWhereStmt) (res sql.Result, err error) {
	var w string
	if where != nil {
		w = where.String()
	}
	buf := util.Builder{}
	buf.Grow(len(UserInfoSQL_Delete) + len(w))
	buf.Write([]byte(UserInfoSQL_Delete))
	buf.WriteString(w)
	res, err = t.db.ExecContext(ctx, buf.String())
	if err != nil {
		return nil, fmt.Errorf("exec db_user.user_info delete_many failed,%w", err)
	}

	return
}

func (t *xUserInfoOperation) RangeAll(ctx context.Context, where *UserInfoWhereStmt, f func(ctx context.Context, row *dbop.UserInfo) bool) error {
	var findSql = UserInfoSQL_Find
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	count := 0
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return fmt.Errorf("exec db_user.user_info range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := scanUserInfo(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}

func (t *xUserInfoOperation) RangeAllEx(ctx context.Context, where *UserInfoWhereStmt, f func(ctx context.Context, row *dbop.UserInfoEx) bool) error {
	var findSql = UserInfoSQL_FindRow
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	count := 0
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return fmt.Errorf("exec db_user.user_info range_all failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()
		count = 0
		for rows.Next() {
			data, err := scanUserInfoEx(rows)
			if err != nil {
				return err
			}
			if !f(ctx, data) {
				return nil
			}
			count++
		}
		if count < limit {
			break
		}
		offset += limit
	}
	return nil
}

func (t *xUserInfoOperation) AllData(ctx context.Context, where *UserInfoWhereStmt) (datas []*dbop.UserInfo, err error) {
	var findSql = UserInfoSQL_Find
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	datas = make([]*dbop.UserInfo, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return nil, fmt.Errorf("exec db_user.user_info all_data failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := scanUserInfo(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}

func (t *xUserInfoOperation) AllDataEx(ctx context.Context, where *UserInfoWhereStmt) (datas []*dbop.UserInfoEx, err error) {
	var findSql = UserInfoSQL_FindRow
	limit := 0
	if where != nil {
		findSql += where.String()
		limit = where.limit
	}
	if limit == 0 {
		limit = 512
	}
	offset := 0
	datas = make([]*dbop.UserInfoEx, 0, limit)
	for {
		buf := util.Builder{}
		buf.Grow(32)
		buf.Write([]byte(" limit "))
		buf.WriteInt(offset)
		buf.WriteByte(',')
		buf.WriteInt(limit)
		rows, err := t.db.QueryContext(ctx, findSql+buf.String())
		if err != nil {
			return nil, fmt.Errorf("exec db_user.user_info all_data_ex failed, offset:%d limit:%d %w", offset, limit, err)
		}
		defer rows.Close()

		for rows.Next() {
			data, err := scanUserInfoEx(rows)
			if err != nil {
				return nil, err
			}
			datas = append(datas, data)
		}
		if len(datas) < offset+limit {
			break
		}
		offset += limit
	}
	return
}

func (t *xUserInfoOperation) DB() *sqlx.DB {
	return t.db
}

////////////////////////////////////////////////////////////////////////////////
// where stmt

type UserInfoWhereStmt struct {
	buf           util.Builder
	limit, offset int
}

func (w *UserInfoWhereStmt) Uid() *svc_db.IntSignedCondition[UserInfoWhereStmt, int64] {
	return svc_db.NewIntSignedCondition[UserInfoWhereStmt, int64](w, &w.buf, "uid")
}

func (w *UserInfoWhereStmt) Name() *svc_db.StringCondition[UserInfoWhereStmt] {
	return svc_db.NewStringCondition[UserInfoWhereStmt](w, &w.buf, "name")
}

func (w *UserInfoWhereStmt) Email() *svc_db.StringCondition[UserInfoWhereStmt] {
	return svc_db.NewStringCondition[UserInfoWhereStmt](w, &w.buf, "email")
}

func (w *UserInfoWhereStmt) Limit(limit, offset int) *UserInfoWhereStmt {
	w.limit = limit
	w.offset = offset
	return w
}

func (w *UserInfoWhereStmt) And() *UserInfoWhereStmt {
	w.buf.Write([]byte(" and "))
	return w
}

func (w *UserInfoWhereStmt) Or() *UserInfoWhereStmt {
	w.buf.Write([]byte(" or "))
	return w
}

func (w *UserInfoWhereStmt) Group(gf func(w *UserInfoWhereStmt)) *UserInfoWhereStmt {
	w.buf.WriteByte('(')
	gf(w)
	w.buf.WriteByte(')')
	return w
}

func (w *UserInfoWhereStmt) Custom(f func(buf *util.Builder)) *UserInfoWhereStmt {
	f(&w.buf)
	return w
}

func (w *UserInfoWhereStmt) applyLimitAndOffset() {
	if w.limit == 0 && w.offset == 0 {
		return
	}
	w.buf.Write([]byte(" limit "))
	w.buf.WriteInt(w.offset)
	w.buf.WriteByte(',')
	w.buf.WriteInt(w.limit)
}

func (w *UserInfoWhereStmt) String() string {
	return w.buf.String()
}

////////////////////////////////////////////////////////////////////////////////
// scan interface

func scanUserInfo(rows *sql.Rows) (data *dbop.UserInfo, err error) {
	var values [3]sql.RawBytes
	err = rows.Scan(&values[0], &values[1], &values[2])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan failed, %w", err)
	}

	data = &dbop.UserInfo{}
	data.Uid, err = UserInfoUidUnamrshal(values[0])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan uid failed, %w", err)
	}
	data.Name, err = UserInfoNameUnamrshal(values[1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan name failed, %w", err)
	}
	data.Email, err = UserInfoEmailUnamrshal(values[2])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan email failed, %w", err)
	}
	return data, nil
}

func scanUserInfoEx(rows *sql.Rows) (data *dbop.UserInfoEx, err error) {
	var values [3 + 2]sql.RawBytes
	err = rows.Scan(&values[0], &values[1], &values[2], &values[3], &values[3+1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan_ex failed, %w", err)
	}

	data = &dbop.UserInfoEx{}
	data.Uid, err = UserInfoUidUnamrshal(values[0])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan_ex uid failed, %w", err)
	}
	data.Name, err = UserInfoNameUnamrshal(values[1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan_ex name failed, %w", err)
	}
	data.Email, err = UserInfoEmailUnamrshal(values[2])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan_ex email failed, %w", err)
	}
	data.ModifyStamp, err = svc_db.RawToStampInt64(values[3])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan_ex modify_stamp failed, %w", err)
	}
	data.CreateStamp, err = svc_db.RawToStampInt64(values[3+1])
	if err != nil {
		return nil, fmt.Errorf("unmarshal db_user.user_info scan_ex create_stamp failed, %w", err)
	}
	return data, nil
}

////////////////////////////////////////////////////////////////////////////////
// named sql

type UserInfoSQLWriter struct {
	buf util.Builder
}

func (x *UserInfoSQLWriter) Select() *UserInfoNamedSelect {
	x.buf.Write([]byte("select "))
	var v int
	return &UserInfoNamedSelect{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *UserInfoSQLWriter) Update() *UserInfoNamedUpdate {
	x.buf.Write([]byte("update user_info set "))
	var v int
	return &UserInfoNamedUpdate{
		buf: &x.buf,
		n:   &v,
	}
}

func (x *UserInfoSQLWriter) Insert() *UserInfoNamedInsert {
	return &UserInfoNamedInsert{
		buf: &x.buf,
	}
}

func (x *UserInfoSQLWriter) Delete() *UserInfoNamedWhere {
	x.buf.Write([]byte("delete user_info where "))
	return &UserInfoNamedWhere{
		buf: &x.buf,
	}
}

type UserInfoNamedInsert struct {
	buf          *util.Builder
	list, values []string
}

func (x *UserInfoNamedInsert) Uid() *UserInfoNamedInsert {
	x.list = append(x.list, "`uid`")
	x.values = append(x.values, ":uid")
	return x
}

func (x *UserInfoNamedInsert) Name() *UserInfoNamedInsert {
	x.list = append(x.list, "`name`")
	x.values = append(x.values, ":name")
	return x
}

func (x *UserInfoNamedInsert) Email() *UserInfoNamedInsert {
	x.list = append(x.list, "`email`")
	x.values = append(x.values, ":email")
	return x
}

func (x *UserInfoNamedInsert) ModifyStamp() *UserInfoNamedInsert {
	x.list = append(x.list, "`modify_stamp`")
	x.values = append(x.values, ":modify_stamp")
	return x
}

func (x *UserInfoNamedInsert) CreateStamp() *UserInfoNamedInsert {
	x.list = append(x.list, "`create_stamp`")
	x.values = append(x.values, ":create_stamp")
	return x
}

func (x *UserInfoNamedInsert) ToSQL() string {
	x.buf.Write([]byte("insert user_info("))
	x.buf.WriteString(strings.Join(x.list, ","))
	x.buf.Write([]byte(") values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

func (x *UserInfoNamedInsert) ValuesToSQL() string {
	x.buf.Write([]byte(",values("))
	x.buf.WriteString(strings.Join(x.values, ","))
	x.buf.Write([]byte(")"))
	return x.buf.String()
}

type UserInfoNamedUpdate struct {
	buf    *util.Builder
	n      *int
	values *bool
}

func (x *UserInfoNamedUpdate) Uid() *UserInfoNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`uid`=values(`uid`)"))
	} else {
		x.buf.Write([]byte("`uid`=:uid"))
	}
	*x.n++
	return x
}

func (x *UserInfoNamedUpdate) Name() *UserInfoNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`name`=values(`name`)"))
	} else {
		x.buf.Write([]byte("`name`=:name"))
	}
	*x.n++
	return x
}

func (x *UserInfoNamedUpdate) Email() *UserInfoNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`email`=values(`email`)"))
	} else {
		x.buf.Write([]byte("`email`=:email"))
	}
	*x.n++
	return x
}

func (x *UserInfoNamedUpdate) ModifyStamp() *UserInfoNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`modify_stamp`=values(`modify_stamp`)"))
	} else {
		x.buf.Write([]byte("`modify_stamp`=:modify_stamp"))
	}
	*x.n++
	return x
}

func (x *UserInfoNamedUpdate) CreateStamp() *UserInfoNamedUpdate {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	if x.values != nil && *x.values {
		x.buf.Write([]byte("`create_stamp`=values(`create_stamp`)"))
	} else {
		x.buf.Write([]byte("`create_stamp`=:create_stamp"))
	}
	*x.n++
	return x
}

func (x *UserInfoNamedUpdate) Where() *UserInfoNamedWhere {
	if x.values != nil {
		panic("invalid where")
	}
	x.buf.Write([]byte(" where "))
	return &UserInfoNamedWhere{
		buf: x.buf,
	}
}

func (x *UserInfoNamedUpdate) ToSQL() string {
	return x.buf.String()
}

type UserInfoNamedSelect struct {
	buf *util.Builder
	n   *int
}

func (x *UserInfoNamedSelect) Uid() *UserInfoNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`uid`"))
	*x.n++
	return x
}

func (x *UserInfoNamedSelect) Name() *UserInfoNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`name`"))
	*x.n++
	return x
}

func (x *UserInfoNamedSelect) Email() *UserInfoNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`email`"))
	*x.n++
	return x
}

func (x *UserInfoNamedSelect) ModifyStamp() *UserInfoNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`modify_stamp`"))
	*x.n++
	return x
}

func (x *UserInfoNamedSelect) CreateStamp() *UserInfoNamedSelect {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`create_stamp`"))
	*x.n++
	return x
}

func (x *UserInfoNamedSelect) Where() *UserInfoNamedWhere {
	x.buf.Write([]byte(" from user_info where "))
	return &UserInfoNamedWhere{
		buf: x.buf,
	}
}

func (x *UserInfoNamedSelect) ToSQL() string {
	x.buf.Write([]byte(" from user_info"))
	return x.buf.String()
}

type UserInfoNamedWhere struct {
	buf *util.Builder
}

func (x *UserInfoNamedWhere) Uid() *UserInfoNamedWhere {
	x.buf.Write([]byte("`uid` = :uid"))
	return x
}

func (x *UserInfoNamedWhere) Name() *UserInfoNamedWhere {
	x.buf.Write([]byte("`name` = :name"))
	return x
}

func (x *UserInfoNamedWhere) Email() *UserInfoNamedWhere {
	x.buf.Write([]byte("`email` = :email"))
	return x
}

func (x *UserInfoNamedWhere) ModifyStamp() *UserInfoNamedWhere {
	x.buf.Write([]byte("`modify_stamp` = :modify_stamp"))
	return x
}

func (x *UserInfoNamedWhere) CreateStamp() *UserInfoNamedWhere {
	x.buf.Write([]byte("`create_stamp` = :create_stamp"))
	return x
}

func (x *UserInfoNamedWhere) Limit(limit, offset int) *UserInfoNamedWhere {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *UserInfoNamedWhere) And() *UserInfoNamedWhere {
	x.buf.Write([]byte(" and "))
	return x
}

func (x *UserInfoNamedWhere) Or() *UserInfoNamedWhere {
	x.buf.Write([]byte(" or "))
	return x
}

func (x *UserInfoNamedWhere) Group(gf func(w *UserInfoNamedWhere)) *UserInfoNamedWhere {
	x.buf.WriteByte('(')
	gf(x)
	x.buf.WriteByte(')')
	return x
}

func (x *UserInfoNamedWhere) Custom(f func(buf *util.Builder)) *UserInfoNamedWhere {
	f(x.buf)
	return x
}

func (x *UserInfoNamedWhere) OnDuplicateKeyUpdate() *UserInfoNamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := false
	return &UserInfoNamedUpdate{
		buf:    x.buf,
		n:      &v,
		values: &values,
	}
}

func (x *UserInfoNamedWhere) OnDuplicateKeyUpdateValues() *UserInfoNamedUpdate {
	x.buf.Write([]byte(" on duplicate key update "))
	var v int
	values := true
	return &UserInfoNamedUpdate{
		buf:    x.buf,
		n:      &v,
		values: &values,
	}
}

func (x *UserInfoNamedWhere) ToSQL() string {
	return x.buf.String()
}

func (x *UserInfoNamedWhere) OrderBy() *UserInfoNamedOrderBy {
	x.buf.Write([]byte(" order by "))
	var v int
	return &UserInfoNamedOrderBy{
		buf: x.buf,
		n:   &v,
	}
}

type UserInfoNamedOrderBy struct {
	buf *util.Builder
	n   *int
}

func (x *UserInfoNamedOrderBy) Uid() *UserInfoNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`uid`"))
	*x.n++
	return &UserInfoNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserInfoNamedOrderBy) Name() *UserInfoNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`name`"))
	*x.n++
	return &UserInfoNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserInfoNamedOrderBy) Email() *UserInfoNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`email`"))
	*x.n++
	return &UserInfoNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserInfoNamedOrderAsc) ModifyStamp() *UserInfoNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`modify_stamp`"))
	*x.n++
	return &UserInfoNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserInfoNamedOrderAsc) CreateStamp() *UserInfoNamedOrderAsc {
	if *x.n > 0 {
		x.buf.WriteByte(',')
	}
	x.buf.Write([]byte("`create_stamp`"))
	*x.n++
	return &UserInfoNamedOrderAsc{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserInfoNamedOrderBy) Limit(limit, offset int) *UserInfoNamedOrderBy {
	x.buf.Write([]byte(" limit "))
	x.buf.WriteInt(offset)
	x.buf.WriteByte(',')
	x.buf.WriteInt(limit)
	return x
}

func (x *UserInfoNamedOrderBy) ToSQL() string {
	return x.buf.String()
}

type UserInfoNamedOrderAsc struct {
	buf *util.Builder
	n   *int
}

func (x *UserInfoNamedOrderAsc) Asc() *UserInfoNamedOrderBy {
	x.buf.Write([]byte(" asc "))
	return &UserInfoNamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserInfoNamedOrderAsc) Desc() *UserInfoNamedOrderBy {
	x.buf.Write([]byte(" desc "))
	return &UserInfoNamedOrderBy{
		buf: x.buf,
		n:   x.n,
	}
}

func (x *UserInfoNamedOrderAsc) ToSQL() string {
	return x.buf.String()
}
