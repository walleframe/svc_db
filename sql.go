package svc_db

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/jmoiron/sqlx"
	"go.uber.org/multierr"
)

type EmptyResult struct{}

// A Result summarizes an executed SQL command.
var _ sql.Result = EmptyResult{}

// LastInsertId returns the integer generated by the database
// in response to a command. Typically this will be from an
// "auto increment" column when inserting a new row. Not all
// databases support this feature, and the syntax of such
// statements varies.
func (EmptyResult) LastInsertId() (int64, error) {
	return 0, nil
}

// RowsAffected returns the number of rows affected by an
// update, insert, or delete. Not every database or database
// driver may support this.
func (EmptyResult) RowsAffected() (int64, error) {
	return 0, nil
}

func existsTable(ctx context.Context, db *sqlx.DB, tableName string) (exists bool, err error) {
	rows, err := db.QueryContext(ctx, "show tables")
	if err != nil {
		return false, fmt.Errorf("show tables failed, %w", err)
	}
	defer rows.Close()
	var name string
	for rows.Next() {
		err = rows.Scan(&name)
		if err != nil {
			break
		}
		if tableName == name {
			exists = true
			break
		}
	}
	return
}

// scanTableColumns only scan column name list.
func scanTableColumns(ctx context.Context, db *sqlx.DB, tableName string) (columns map[string]struct{}, err error) {
	s := fmt.Sprintf("show columns from `%s`", tableName)
	rows, err := db.QueryContext(ctx, s)
	if err != nil {
		return nil, fmt.Errorf("%s failed, %w", s, err)
	}
	defer rows.Close()
	columns = make(map[string]struct{})
	for rows.Next() {
		var fieldName string
		// | Field     | Type         | Null | Key | Default | Extra          |
		err = rows.Scan(&fieldName, &sql.NullString{}, &sql.NullString{}, &sql.NullString{}, &sql.NullString{}, &sql.NullString{})
		if err != nil {
			return nil, fmt.Errorf("%s failed,%w", s, err)
		}
		columns[fieldName] = struct{}{}
	}
	return
}

// SyncTableColumns sync table columns, do not check column type, only add missing columns.if table not exists, create it.
func SyncTableColumns(ctx context.Context, db *sqlx.DB, tableName string, createTable string, alterSql map[string]string) (err error) {
	if !SyncTableColumnsAndIndex {
		return
	}
	exists, err := existsTable(ctx, db, tableName)
	if err != nil {
		return err
	}
	if !exists {
		_, err = db.ExecContext(ctx, createTable)
		return
	}

	columns, err := scanTableColumns(ctx, db, tableName)
	if err != nil {
		return err
	}

	for k, v := range alterSql {
		if _, ok := columns[k]; ok {
			continue
		}
		_, err2 := db.ExecContext(ctx, v)
		if err2 != nil {
			err = multierr.Append(err, err2)
		}
	}

	return
}

// scanTableIndex only scan index name is exists.
func scanTableIndex(ctx context.Context, db *sqlx.DB, tableName, indexName string) (exists bool, err error) {
	s := fmt.Sprintf("show index from `%s` where `Key_name` = ?", tableName)
	rows, err := db.QueryContext(ctx, s, indexName)
	if err != nil {
		return false, fmt.Errorf("%s failed, %w", s, err)
	}
	defer rows.Close()
	for rows.Next() {
		exists = true
		break
	}
	return
}

// SyncTableIndex sync table index, create missing index.
func SyncTableIndex(ctx context.Context, db *sqlx.DB, tableName string, alterSql map[string]string) (err error) {
	if !SyncTableColumnsAndIndex {
		return
	}
	var exists bool
	for name, alter := range alterSql {
		if exists, err = scanTableIndex(ctx, db, tableName, name); err != nil {
			return err
		}
		if exists {
			continue
		}
		_, err2 := db.ExecContext(ctx, alter)
		if err2 != nil {
			err = multierr.Append(err, err2)
		}
	}
	return
}
